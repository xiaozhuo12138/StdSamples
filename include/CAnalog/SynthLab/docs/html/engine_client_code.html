<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthEngine Client-Side Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('engine_client_code.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SynthEngine Client-Side Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Programming the SynthEngine from the client-side (from your plugin framework) was designed to be as simple as possible, requiring only a handful of function calls. The most important code that you will need to write involves setting up the <b>SynthBlockProc</b> structure that contains your audio buffers and MIDI messages for a single block process render cycle. Note that this code is going to be extremely dependent on your plugin framework and you will need to know how to access your client's audio and MIDI data buffers. <br />
</p>
<h2>SynthProcessInfo Structure </h2>
<p>The <b>SynthProcessInfo</b> structure is covered in <a class="el" href="the_block.html">Block Audio Processing</a> and this is key to the engine's operation as it is the argument that is passed during the render() call to service MIDI events and to fill buffers with synthesized audio. In my implementations, the framework's processing object creates a static instance of the structure, initializes it, and then loads it with MIDI events prior to calling the render function. <br />
</p>
<p>Setting up and initializing your SynthProcessInfo struct is simple:</p><ol type="1">
<li>declare/instantiate the structure</li>
<li>call the init() function to allocate the audio input and output buffers; typically this is done one and only one time, but if you want to change the input/output channel count or the block size <b>before the SynthEngine is created</b>, just call the init() function again with the new parameters. NOTE: once the SynthEngine has been constructed, you can not change the buffer sizes!</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// --- setup proc structure</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synthbase_8h.html">synthbase.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// --- (1) static instance</span></div><div class="line"><a class="code" href="class_synth_lab_1_1_synth_process_info.html">SynthLab::SynthProcessInfo</a> synthBlockProcInfo;</div><div class="line"></div><div class="line"><span class="comment">// --- (2) one time initiailization</span></div><div class="line">synthBlockProcInfo.<a class="code" href="class_synth_lab_1_1_audio_buffer.html#aba136b0da5ee3db505c2cbf08758a950">init</a>(<a class="code" href="group___constants-_enums.html#ga5aa686803c275f895c0f456702b01488">SynthLab::NO_CHANNELS</a>,      <span class="comment">/* number of input audio channels; use for sidechain inputs; not used in SynthLab examples */</span></div><div class="line">                        SynthLab::STEREO_CHANNELS,  <span class="comment">/* number of output audio channels; all SynthLab synths feature a stereo output */</span></div><div class="line">                        64);                        <span class="comment">/* block size in frames: 64 = 64 sets of stereo frames (2 samples/channel) */</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>MIDI Events</b> <br />
 You will need to push the MIDI events that occurred during the time in the audio block into the structure prior to calling the render() method on the synth. There are two functions to help; one which clears out the last set of MIDI events and another to push a new event on the FIFO stack (which is really just a std::vector). See the <a class="el" href="ex_m_i_d_ievents.html">MIDI Note Events</a> section for information on MIDI event structures and <a class="el" href="the_m_i_d_i.html">Enqueueing MIDI Events</a> section for more information about adding MIDI events to the SynthProcessInfo's queue. You code will look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// --- always clear out the events from the last audio block process</span></div><div class="line">synthBlockProcInfo.<a class="code" href="class_synth_lab_1_1_synth_process_info.html#acf3af6a93a225290d1a8ac4ca623cadb">clearMidiEvents</a>();</div><div class="line"></div><div class="line"><span class="comment">// --- parse MIDI events that occur during each audio block and create the event structure</span></div><div class="line"><a class="code" href="struct_synth_lab_1_1midi_event.html">SynthLab::midiEvent</a> synthEvent(NOTE_ON, <span class="comment">/* NOTE_ON is declared in synthconstants.h */</span></div><div class="line">                               0,       <span class="comment">/* Channel 0 (MIDI Channel 1) */</span></div><div class="line">                               60,      <span class="comment">/* midi note number, Middle C */</span></div><div class="line">                               127,     <span class="comment">/* velocity */</span></div><div class="line">                               0);      <span class="comment">/* buffer time, not used */</span></div><div class="line"></div><div class="line"><span class="comment">// --- and push structure into SynthProcessInfo, which adds them to its vector</span></div><div class="line">synthBlockProcInfo.<a class="code" href="class_synth_lab_1_1_synth_process_info.html#a04a05b4370103181b3821a68644b838a">pushMidiEvent</a>(synthEvent);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>SynthEngine Operational Phases </h2>
<p>The rest of the SynthEngine operation is simple, as long as you have the SynthProcessInfo structure initialized and ready to be loaded with MIDI events. There are four operational phases plus creation:</p><ol type="1">
<li>reset with sample rate (must be done any time the sample rate changes)</li>
<li>initialize with path information (path information is needed for PCM samples, and optional for everything else)</li>
<li>do GUI control updates</li>
</ol>
<ol type="1">
<li>render audio into output buffers</li>
</ol>
<p><b>Creation</b> <br />
 The SynthEngine needs to know the audio block processing size from the very beginning of its existence. Once set, this size should not change. You have two options for declaring the SynthEngine:</p><ol type="1">
<li>static: if you declare a static instance of the engine, the block size is set to 64 automatically, and can not be changed</li>
<li>dynamic: you provide the block size in the constructor of the dynamically allocated object</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// --- static;</span></div><div class="line"><a class="code" href="class_synth_lab_1_1_synth_engine.html">SynthLab::SynthEngine</a> theStaticEngine; <span class="comment">//&lt; -- block size is 64 by default</span></div><div class="line"></div><div class="line"><span class="comment">// --- dynamic with smart pointer</span></div><div class="line">synthEngine.<a class="code" href="class_synth_lab_1_1_synth_engine.html#aff01a18eb1e6f3d60cf7ac57e1263ea6">reset</a>(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_synth_engine.html">SynthLab::SynthEngine</a>(64)); <span class="comment">//&lt; -- adjust block size here</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Reset and Initialize</b> <br />
 The reset and intialize phases are simple requiring one function all each and described in <a class="el" href="engine_templ.html">SynthEngine Template Code</a>; note that these should normally be called in succession, startint with the reset() function. One of the reasons for the ordering here involves the location of the path variable for the initialize() function, which may not be known at construction time on the framework processing object. Since it is likely you will instantiate the engine as part of construction, the initialize() function must not be called until you have the path to send it. See <a class="el" href="engine_templ.html">SynthEngine Template Code</a> for more information on this path.</p>
<div class="fragment"><div class="line"><span class="comment">// --- reset called anytime sample rate changes</span></div><div class="line"><span class="comment">//     NOTE: SynthLab is designed for 44.1kHz and 48kHz with regards to the wavetables and PCM samples!</span></div><div class="line">synthEngine-&gt;reset(44100.0); <span class="comment">//&lt; get fs from your framework</span></div><div class="line"></div><div class="line"><span class="comment">// --- once the fully qualified path is known:</span></div><div class="line">synthEngine-&gt;initialize(path.c_str()); <span class="comment">//&lt; -- get path to DLL folder from framework or hardcode </span></div><div class="line">                                       <span class="comment">//&lt;    hardcoding is not a good solution but OK for testing algorithms</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>GUI Parameter Updates</b> <br />
 Details about the GUI update cycle and example code are avaialble in <a class="el" href="the_params.html">Updating GUI Parameters</a>. You get the parameter structure pointers, alter variables with them, then call the update function.</p>
<div class="fragment"><div class="line"><span class="comment">// --- for GUI parameter updating</span></div><div class="line">std::shared_ptr&lt;SynthLab::SynthEngineParameters&gt; engineParameters = <span class="keyword">nullptr</span>;</div><div class="line">std::shared_ptr&lt;SynthLab::SynthVoiceParameters&gt; voiceParameters = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="comment">// --- during initialization/instantiation of framework&#39;s processing object</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// --- get the engine parameters</span></div><div class="line">synthEngine-&gt;getParameters(engineParameters);</div><div class="line"></div><div class="line"><span class="comment">// --- get the voice parameters from the engine parameters</span></div><div class="line">voiceParameters = engineParameters-&gt;voiceParameters;</div><div class="line"></div><div class="line"><span class="comment">// --- set the various parameters for the engine-level and voice-level components</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// --- engine </span></div><div class="line">engineParameters-&gt;globalPitchBendSensCoarse = 12; <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">engineParameters-&gt;globalTuningCoarse = -8.750;    <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line"></div><div class="line">engineParameters-&gt;globalUnisonDetune_Cents = 10.0; <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">engineParameters-&gt;globalVolume_dB = -6.00;         <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line"></div><div class="line"><span class="comment">// --- voice updates</span></div><div class="line">voiceParameters-&gt;glideTime_mSec = 1000.0;                 <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">voiceParameters-&gt;lfo1Parameters-&gt;frequency_Hz = 0.25;     <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">voiceParameters-&gt;lfo1Parameters-&gt;outputAmplitude = 0.707; <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line"></div><div class="line"><span class="comment">// filter EG</span></div><div class="line">voiceParameters-&gt;filterEGParameters-&gt;attackTime_mSec = 20.0;  <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">voiceParameters-&gt;filterEGParameters-&gt;decayTime_mSec = 250.0;  <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line"><span class="comment">// etc...</span></div><div class="line"></div><div class="line"><span class="comment">// --- oscillator output amplitudes for four member oscillators</span></div><div class="line">voiceParameters-&gt;osc1Parameters-&gt;outputAmplitude_dB = 0.0;  <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line">voiceParameters-&gt;osc2Parameters-&gt;outputAmplitude_dB = +3.5; <span class="comment">// &lt;-- get this value from your GUI</span></div><div class="line"><span class="comment">// etc...</span></div><div class="line"></div><div class="line"><span class="comment">// --- then call the setParameter() function for updates</span></div><div class="line"><span class="comment">//     NOTE: the argument here is usually the same as the parameter structure you accessed earlier</span></div><div class="line"><span class="comment">//           however, it is possible to get the engine a separate parameter structure; this could</span></div><div class="line"><span class="comment">//           be used for advanced GUIs with multiple variation panels; this paradigm is not used in SynthLab</span></div><div class="line"><span class="comment">//           examples, which always use the original parameter struct pointer</span></div><div class="line">synthEngine-&gt;setParameters(engineParameters); </div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Render Audio and Access Buffers</b> <br />
 With the SynthProcessInfo structure (named synthBlockProcInfo here) prepared and loaded with one block's worth of MIDI events, you then call the render() method, passing in this single structure as the argument. Once render() returns, you can access the audio data in the buffers and send them to your framework's output buffers.</p><ul>
<li>note that you do not need to clear out the audio buffers once done; each call to render() will wipe the buffers clean for the next render cycle</li>
<li>SynthLab examples are all stereo synths but you may also create mono versions; in that case only the channel = 0 array will be valid</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- render it</span></div><div class="line">synthEngine-&gt;render(synthBlockProcInfo);</div><div class="line"></div><div class="line"><span class="comment">// --- get output buffer and write to framework</span></div><div class="line"><span class="keywordtype">float</span>** synthOutputs = synthBlockProcInfo.getOutputBuffers();</div><div class="line"></div><div class="line"><span class="comment">// --- block processing -- write to outputs</span></div><div class="line"><span class="keywordflow">for</span> (uint32_t sample = processBlockInfo.blockStartIndex, i = 0; </div><div class="line">     sample &lt; processBlockInfo.blockStartIndex + processBlockInfo.blockSize; </div><div class="line">     sample++, i++)</div><div class="line">{</div><div class="line">     <span class="comment">// --- copy to outputs</span></div><div class="line">     <span class="keywordflow">for</span> (uint32_t channel = 0; channel &lt; processBlockInfo.numAudioOutChannels; channel++)</div><div class="line">     {</div><div class="line">         &lt;your framework output buffer&gt;[channel][sample] = synthOutputs[channel][i];</div><div class="line">     }</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Engine Destruction</b> <br />
 In the example here using smart pointers, there is nothing to do but let the smart pointer delete itself. If you declare the engine statically, it will be destroyed in a likewise manner in your processing object's destructor. If you use old fashioned allocation and pointers, you need to call the <b>delete</b> operator manually. There are numerous data arrays to clear, and for the SynthLab-PCM synth, around 1.4GB of PCM samples to delete, so the destruction phase is quite important! <br />
</p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_voice_engine.html">Engine &amp; Voice Programming</a></li><li class="navelem"><a class="el" href="the_engine.html">SynthEngine Object</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
