<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthEngine Template Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('engine_templ.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SynthEngine Template Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>You can find the SynthEngine template code in the SynthLab_SDK/source folder in two files, <b>synthengine.h</b> and <b>synthengine.cpp</b>. This is the minimum implementation but with a bunch of helper code already added for you that mostly deals with deocding MIDI messages, and managing the array of voice objects that do the rendering.</p>
<h2>SynthEngine Operational Phases </h2>
<p>The SynthEngine Operational Phases are discussed in detail in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> and so that theory will not be repeated here. However, we do want to to step through the operational phase methods, declared as virtual as these are the main interface functions that the SynthEngine will be calling.</p>
<h2>Construction Phase </h2>
<p>For the SynthEngine, there is no such thing as "standalone" operation as it is alredy in standalone mode, acting as the sole object your frameowork needs to interact with. The engine is the fountainhead of all synth shared databases, parameters, and MIDI data and most of that is created within at construction.</p>
<p><b>Constructor</b> <br />
 The constructor's main role is in constructing the SynthVoice members, passing them the shared resources that are instantiated during construction. Your plugin framework will instantiate the object and the constructor requires a committment by passing the <b>maximum</b> block size during instantiation. The framework may always render blocks smaller than this size. The constructor has only one argument, which is that block size.</p>
<div class="fragment"><div class="line">SynthEngine::SynthEngine(uint32_t blockSize)</div><div class="line">{</div><div class="line">     <span class="comment">// --- create databases</span></div><div class="line">     <span class="keywordflow">if</span> (!wavetableDatabase)</div><div class="line">          wavetableDatabase = std::make_shared&lt;WavetableDatabase&gt;();</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span> (!sampleDatabase)</div><div class="line">          sampleDatabase = std::make_shared&lt;PCMSampleDatabase&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- create the smart pointers</span></div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="group___constants-_enums.html#gaa0c9031b49d3e67b7f14488ced344c74">MAX_VOICES</a>; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- reset is the constructor for this kind of smartpointer</span></div><div class="line">          <span class="comment">//</span></div><div class="line">          <span class="comment">//     Pass our this pointer for the IMIDIData interface - safe</span></div><div class="line">          synthVoices[i].reset(<span class="keyword">new</span> SynthVoice(midiInputData,                <span class="comment">/* shared MIDI input data */</span></div><div class="line">                                              midiOutputData,               <span class="comment">/* shared MIDI output data; not used in example synths */</span></div><div class="line">                                              parameters-&gt;voiceParameters,  <span class="comment">/* shared voice parameters */</span></div><div class="line">                                              wavetableDatabase,            <span class="comment">/* shared wavetable data */</span></div><div class="line">                                              sampleDatabase,               <span class="comment">/* shared PCM sample data */</span></div><div class="line">                                              blockSize));                  <span class="comment">/* maximum block processing size */</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- voice object</span></div><div class="line">     voiceProcessInfo.init(0, 2, blockSize);</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p><b>Destructor</b> <br />
 The SynthEngine is one of a few objects with a dedicated destructor as nearly all dynamic resources are maintained with smart pointers. The destructor is used to elimiate all dynamically declared PCM sample arrays that were extracted from WAV files at load time, and then later shared via the PCM sample database.</p>
<div class="fragment"><div class="line"><span class="comment">// --- destroy me</span></div><div class="line">SynthEngine::~SynthEngine()</div><div class="line">{</div><div class="line">     <span class="keywordflow">if</span> (sampleDatabase)</div><div class="line">          sampleDatabase-&gt;clearSampleSources();</div><div class="line">}</div></div><!-- fragment --><h2>Reset &amp; Intialize Phase </h2>
<p>The SynthEngine simply forwards these calls to its member voice objects and these are direct consequences of your plugin framework calling reset() and initialize() at load time.</p>
<div class="fragment"><div class="line"><span class="comment">// --- reset sub-objects</span></div><div class="line"><span class="keywordtype">bool</span> SynthEngine::reset(<span class="keywordtype">double</span> _sampleRate)</div><div class="line">{</div><div class="line">     <span class="comment">// --- reset array of voices</span></div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="group___constants-_enums.html#gaa0c9031b49d3e67b7f14488ced344c74">MAX_VOICES</a>; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- smart poitner access looks normal (-&gt;)</span></div><div class="line">          synthVoices[i]-&gt;reset(_sampleRate); <span class="comment">// this calls reset() on the smart-pointers underlying naked pointer</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- Initialize sub-objects</span></div><div class="line"><span class="keywordtype">bool</span> SynthEngine::initialize(<span class="keyword">const</span> <span class="keywordtype">char</span>* dllPath)</div><div class="line">{</div><div class="line">     <span class="comment">// --- loop</span></div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="group___constants-_enums.html#gaa0c9031b49d3e67b7f14488ced344c74">MAX_VOICES</a>; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- init</span></div><div class="line">          synthVoices[i]-&gt;initialize(dllPath);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Update Phase </h2>
<p>Your plugin framework will access the engine's parameter structure pointers and use them to alter variables based on the user's GUI control settings. After that, the framework should call the SynthEngine::setParameters() method to perform the updates. The engine template code is very light, simply calling the update() method on the voices. When you add unison mode, or any other mode of operation that affect voices in a different way, you need to add that code here. For example in unison mode, the SynthLab example synths will set the voice detuning, and oscillator starting phases during this function. We will add this code in the next section.</p>
<div class="fragment"><div class="line"><span class="comment">// --- set parameters is the update() function for the engine</span></div><div class="line"><span class="keywordtype">void</span> SynthEngine::setParameters(std::shared_ptr&lt;SynthEngineParameters&gt;&amp; _parameters)</div><div class="line">{</div><div class="line">     <span class="comment">// --- store parameters</span></div><div class="line">     parameters = _parameters;</div><div class="line"></div><div class="line">     <span class="comment">// --- engine mode: poly, mono or unison</span></div><div class="line">     parameters-&gt;voiceParameters-&gt;synthModeIndex = parameters-&gt;synthModeIndex;</div><div class="line"></div><div class="line">     <span class="comment">// --- update the voices one by one; the voice does NOT update it sub-components here</span></div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="group___constants-_enums.html#gaa0c9031b49d3e67b7f14488ced344c74">MAX_VOICES</a>; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- needed for modules</span></div><div class="line">          synthVoices[i]-&gt;update();</div><div class="line">     }</div><div class="line">}</div><div class="line"><span class="comment">// --- </span></div></div><!-- fragment --><h2>Render Phase </h2>
<p>The render phase is detailed in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> and questions about the block processing or other details are answered there so it will not be repeated here. The render phase is very simple and has three parts:</p><ol type="1">
<li>process the MIDI messgages for the entire block of data, one message at a time until the queue is empty</li>
<li>loop through the active voices, call the render() function on them, and accumulate their audio output buffers</li>
<li>apply global volume and (optionally) global FX (called master FX in many manuals)</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// --- voice render template code</span></div><div class="line"><span class="keywordtype">bool</span> SynthEngine::render(SynthProcessInfo&amp; synthProcessInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- may do thie before</span></div><div class="line">     synthProcessInfo.flushBuffers();</div><div class="line"></div><div class="line">     <span class="comment">// --- issue MIDI events for this block</span></div><div class="line">     uint32_t midiEvents = synthProcessInfo.getMidiEventCount();</div><div class="line">     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; midiEvents; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- get the event</span></div><div class="line">          midiEvent <span class="keyword">event</span> = *synthProcessInfo.getMidiEvent(i);</div><div class="line">     </div><div class="line">          <span class="comment">// --- process it</span></div><div class="line">          processMIDIEvent(event);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- -12dB per active channel to avoid clipping</span></div><div class="line">     <span class="keywordtype">double</span> gainFactor = 1.0;</div><div class="line"></div><div class="line">     <span class="comment">// --- this is important</span></div><div class="line">     voiceProcessInfo.setSamplesInBlock(synthProcessInfo.getSamplesInBlock());</div><div class="line"></div><div class="line">     midiInputData-&gt;setAuxDAWDataFloat(kBPM, synthProcessInfo.BPM);</div><div class="line">     midiInputData-&gt;setAuxDAWDataFloat(kTSNumerator, synthProcessInfo.timeSigNumerator);</div><div class="line">     midiInputData-&gt;setAuxDAWDataUINT(kTSDenominator, synthProcessInfo.timeSigDenomintor);</div><div class="line">     midiInputData-&gt;setAuxDAWDataFloat(kAbsBufferTime, synthProcessInfo.absoluteBufferTime_Sec);</div><div class="line">     </div><div class="line">     <span class="comment">// --- loop through voices and render/accumulate them</span></div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="group___constants-_enums.html#gaa0c9031b49d3e67b7f14488ced344c74">MAX_VOICES</a>; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- blend active voices</span></div><div class="line">          <span class="keywordflow">if</span> (synthVoices[i]-&gt;isVoiceActive())</div><div class="line">          {</div><div class="line">               <span class="comment">// --- render and accumulate</span></div><div class="line">               synthVoices[i]-&gt;render(voiceProcessInfo);</div><div class="line">               accumulateVoice(synthProcessInfo, gainFactor);</div><div class="line">          }</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- add global volume</span></div><div class="line">     applyGlobalVolume(synthProcessInfo);</div><div class="line"></div><div class="line">     <span class="comment">// --- note that this is const, and therefore read-only</span></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><h2>Render Helper Functions </h2>
<p>The template engine object includes a couple of helper functions for accumulating the voice audio output buffers and applying global volume adjustments.</p>
<div class="fragment"><div class="line"><span class="comment">// --- acculumulate: loop over voices and accumulate their output buffers in parallel</span></div><div class="line"><span class="keywordtype">void</span> SynthEngine::accumulateVoice(SynthProcessInfo&amp; synthProcessInfo, <span class="keywordtype">double</span> scaling)</div><div class="line"></div><div class="line"><span class="comment">// --- apply global volume to the audio in the buffers; use this as a template for applying global effects</span></div><div class="line"><span class="keywordtype">void</span> SynthEngine::applyGlobalVolume(SynthProcessInfo&amp; synthProcessInfo)</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Processing MIDI </h2>
<p>The engine processes incoming MIDI events that it finds in the MIDI event queue in the SynthProcInfo structure that the frameworks passes it during the render operation. The template version is empty, but we will add meaningful MIDI event coding in the next section.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note on</span></div><div class="line"><span class="keywordtype">bool</span> SynthEngine::processMIDIEvent(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>This completes the tour of the template object. In the next section, we will modify the engine template to add the new SynthVoice from the previous section.</p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_voice_engine.html">Engine &amp; Voice Programming</a></li><li class="navelem"><a class="el" href="the_engine.html">SynthEngine Object</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
