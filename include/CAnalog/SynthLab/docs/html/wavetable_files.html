<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Wavetable Files &amp; Database</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('wavetable_files.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Wavetable Files &amp; Database </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <b>wavetables</b> folder includes example wavetable subfolders that store .h files using the SynthLabTableSet data structure for organizing the tables, table names, and lengths. Most of these tables depend on a single .h file that exposes the <b>SynthLabTableSet</b> structure. <b>However, the actual encoding of the wavetables is irrelevant to the synth engine or the database!</b> The example files are just that - examples for you to use. Once you have the wavetable synth running, you will want to replace the tables with your own, and that is very easy to do if you understand how abstract C++ interfaces isolate and hide impelmentation details.<br />
</p>
<h2>Folders </h2>
<p>The wavetable folders consist of files for both single and morphing wavetables. The morphing tables were concocted using WaveEdit and seed waveforms from a variety of sources including found-sounds. WaveEdit provided the cross-table effect modulation. The resulting folders of wave files were processed with RackAFX's TableMaker utility for conversion to static tables packaged in .h files, and encoded as 64-bit hex values. TackAFX TableMaker does provide encryption capability but that was not used in SynthLab. The tables include:</p><ul>
<li><b>static_tables</b>: tables for traditional wavetable synthesis organized in high-resolution sets where an array of pointers stores individual tables for every MIDI note in order to provide the maximum number of harmonics before aliaising, as well as butter-smooth transitions from one table to the next as the pitch modulation is applied.<ul>
<li><b>drumtables</b>, <b>sfxtables</b>: these do not use the SynthLabTableSet and are examples of raw-form tables; they were created using WAV files of individual drum hits and sound effect along and converted to .h file tables using RackAFX TableMaker</li>
<li><b>fm_wt</b>: a varitey of FM waveforms created with WaveEdit</li>
<li><b>vs_wt</b>: a variety of tables created with Prophet-VS patches</li>
<li><b>anasaw</b>: analog sawtooth waveform using analog saw seed in WaveEdit</li>
<li><b>anasquare</b>: analog square waveform using analog square seed in WaveEdit</li>
<li><b>akwf_8</b>: a set of wavetables converted from the AKWF wave file set and table-ized with RackAFX TableMaker</li>
</ul>
</li>
<li><b>dentist</b>: morphing wavetable set from an aribtrary seed in WaveEdit</li>
<li><b>digDoo1</b>: morphing wavetable set from didgeridoo slices in the AKWF set</li>
<li><b>digDoo2</b>: morphing wavetable set from didgeridoo slices in the AKWF set</li>
<li><b>digDoo3</b>: morphing wavetable set from didgeridoo slices in the AKWF set</li>
<li><b>primalwaves</b>: morphing wavetable set of four primitive waveforms: sine, square, saw, triangle</li>
<li><b>sawdemon</b>: morphing wavetable set using a square wave mangled in WaveEdit</li>
<li><b>sinemorph</b>: morphing wavetable set using a sine wave mangled in WaveEdit</li>
<li><b>squareduty</b>: morphing wavetable set using a squarewave whose duty cycle is modulated across the table set</li>
<li><b>squarecomb</b>: morphing wavetable set using a squarewave with a comb filter that is modulated across the table set</li>
<li><b>squarering</b>: morphing wavetable set using a squarewave with a ring modulator that is modulated across the table set</li>
</ul>
<h2>HEX Encoded Tables </h2>
<p>If you examine the wavetable .h files, you will see that the tables are encoded in 64-bit unsigned integer format, which is the output of the RackAFX-TableMaker utility. Storing the data this way allows maximum precision without writing out scores of digits afer the decimal place. The data is converted into <b>double</b> format using the reinterpret_cast operator; reinterpret_cast evaporates during the complile process, and adds zero machine code to the plugin binary. Table reads and interpolation in the example wavetable source objects generally follow this pattern:</p>
<div class="fragment"><div class="line"><span class="comment">// --- two table reads</span></div><div class="line">uint64_t u0 = selectedTable.uTable[readIndex];</div><div class="line">uint64_t u1 = selectedTable.uTable[nextReadIndex];</div><div class="line">wtData[0] = *(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(&amp;u0));</div><div class="line">wtData[1] = *(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">double</span>*<span class="keyword">&gt;</span>(&amp;u1));</div><div class="line"></div><div class="line"><span class="comment">// --- fracPart is the fractional location of the sample for interpolation</span></div><div class="line"><span class="keywordtype">double</span> output = <a class="code" href="group___synth_functions.html#ga73eab44609b0d8cea409be8cb93285cb">doLinearInterpolation</a>(wtData[0], wtData[1], fracPart);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Generic Interface Classes </h2>
<p><b>A key design feature in SynthLab is the use of generic interface classes</b> that allow you to customize things that are programmer-centric (or perhaps company-centric) such as storing wavetables and PCM samples. The <b>IWavetableSource</b> and <b>IWavetableDatabase</b> interfaces are written so that the modules and cores have no information about how the data is stored. <br />
</p>
<p><b>This allows you to write two C++ objects (one for the database and one for the wavetable source) that expose the two interfaces above and then you can connect them directly with the synth engine, which shares the IWavetableDatabase with its voice objects, who share them with their oscillators.</b> <br />
</p>
<h2>IWavetableDatabase </h2>
<p>The wavetable oscillator and its cores access the wavetable information from a shared object that implements the <b>IWavetableDatabase</b> interface. This interface is platform independent and framework/API agnostic. The database object provides a simple set of functions for querying, adding and removing wavetables or sets of wavetables. The objects that use the database do not know any details of how the database stores its information.</p>
<h2>Database Queries </h2>
<p>When each wavetable core is reset, it queries the database to see if its tables exist or not. If a table does not exist, the core provides the <b>IWavetableSource</b> pointer for the database to store. The upshot of this is that the very first core of a given kind will register fresh tables with the database. After that, the other cores will find them, and not attempt to register them. <br />
</p>
<p>During initialization, the wavetable oscillator cores will perform the following steps on the database at initialization time:</p><ul>
<li>checking the database to see if a wavetable exists; the wavetables are identified with <b>unique</b> waveform strings that will be connected to a GUI control that likewise will need to expose unique strings to the user</li>
<li>adding wavetables to the database if they don't exist; wavetable objects implement the IWavetableSource interface, which is used for storing and reading the tables</li>
<li>wavetables may be parsed using <b>either</b> the unique name string (that is on the GUI) or a unique index value; using the index value is much more efficient and when you query or register the wavetable, you may obtain the unique index for each table and store that for parsing</li>
<li>the <b>IWavetableDatabase</b> definition below contains the two different <b>getTableSource</b> parsing functions, one that accepts the unique name string, and the other that uses the index</li>
<li>the index is obtained with the <b>getWaveformIndex</b> if the table has already been registered with the database</li>
<li>if the table has not been added yet, you may retrieve the unique index as a return-by-reference argument of the <b>addTableSource</b> function</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- comments removed</span></div><div class="line"><span class="keyword">class </span>IWavetableDatabase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> IWavetableSource* getTableSource(<span class="keyword">const</span> <span class="keywordtype">char</span>* uniqueTableName) = 0;</div><div class="line">    <span class="keyword">virtual</span> IWavetableSource* getTableSource(uint32_t uniqueTableIndex) { <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> addTableSource(<span class="keyword">const</span> <span class="keywordtype">char</span>* uniqueTableName, IWavetableSource* tableSource, uint32_t&amp; uniqueIndex) = 0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> removeTableSource(<span class="keyword">const</span> <span class="keywordtype">char</span>* uniqueTableName) = 0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> clearTableSources() = 0;</div><div class="line">    <span class="keyword">virtual</span> int32_t getWaveformIndex(<span class="keyword">const</span> <span class="keywordtype">char</span>* uniqueTableName) { <span class="keywordflow">return</span> -1; }</div><div class="line">};</div></div><!-- fragment --><h2>IWavetableSource </h2>
<p>A wavetable or bank of wavetables is contained within a single object that implements the <b>IWavetableSource</b> interface. Note that this applies to single wavetable sets for rendering a static wavetable, as well as for banks (sets of the sets of tables) used in a morphing oscillator. You can think of the IWavetableSource object as rendering one waveatable patch. The IWavetableSource interface is below. You can see that its functions do not allow any kind of access to the underlying table itself &ndash; at no time do the oscillators acually hold a pointer to any table. In fact, the oscillator cores do not know or need to know any details about how the tables are orgainized and stored in the database, nor do they know anything about the actual table encoding, storage, read-back method or interpolation. Likewise, the cores do not control the lifecycles of the wavetable sources as they cannot create or destroy the tables. Think about how you will want to assembly your wavetable source object so that it conforms not only to this interface but also your own method for storing or creating the tables themselves. This interface is used during the oscillator updating and rendering phases. During note event rendering, these oscillator cores will then use the database and:</p><ul>
<li>select a wavetable or morphing bank of tables based on the user's choice (if it has changed while the note is held, or if this is a new note event); the database returns an IWavetableSource pointer</li>
<li>select a particular table from the set based on the oscillator's current pitch, including modulation sources and GUI manipulation; the <b>IWavetableSource::selectTable( )</b> method is used</li>
<li>asks the IWavetableSource for a wavetable sample at a particular location within the table (including interpolation if used) to fill its output buffer with data</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- comments removed</span></div><div class="line"><span class="keyword">class </span>IWavetableSource</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> selectTable(uint32_t midiNoteNumber) = 0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> readWaveTable(<span class="keywordtype">double</span> normalizedPhaseInc) = 0;</div><div class="line">    <span class="keyword">virtual</span> uint32_t getWaveTableLength() = 0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* getWaveformName() = 0;</div><div class="line">};</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>The figure here shows how the interface isolates the implementation details and hides them from the SynthModule or ModuleCore object that accesses them via the <b>IWavetableSource</b> interface functions. Three possible internals are shown and include:</p><ol type="1">
<li>accessing a compiled-in table (this is how most of the wavetable cores are designed as it is the most simple and fool-proof)</li>
<li>accessing a table that was calculated at startup time; the <b>FourierWTCore</b> demonstrates this kind of source</li>
<li><p class="startli">setting up a worker thread and accessing tables from disk <b>at run-time as notes are triggered</b>; this is quite complex and will certianly be programmer or company-centric in nature</p>
<p class="startli"><br />
 </p><div class="image">
<img src="wavetab_1.png" alt="wavetab_1.png"/>
</div>
<p> <br />
</p>
</li>
</ol>
<h2>IWavetableSource Examples </h2>
<p>SynthLab includes multiple example IWavetableSource objects that demonstrate different mechanisms for storing the tables. Morphing wavetables are considered to be a "bank" of tables and are organized under a single bank name string, but <b>ultimately, the wavetables are stored exactly as the others in the wavetable datbase, which only knows about its set of tables, and does not know or need to know whether these tables are for morphing or static use.</b> The example IWavetableSource objects include:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">IWavetableSource  </th><th class="markdownTableHeadNone">Object Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>DynamicTableSource</b>  </td><td class="markdownTableBodyNone">stores dynamically created tables and used in the example module core that synthesizes <br />
 parabola and triangle waveforms at startup; there is one table per octave of MIDI notes   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>StaticTableSource</b>  </td><td class="markdownTableBodyNone">stores static hex encoded wavetables that TableMaker produces with each MIDI note table <br />
 getting its own table that will not alias   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>DrumWTSource</b>  </td><td class="markdownTableBodyNone">a special static avetable source for pitch-less tables such as drums or sound effects   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>SineTableSource</b>  </td><td class="markdownTableBodyNone">stores a single static sinusoidal table of double values that is used for all MIDI notes   </td></tr>
</table>
<p>Figure 9.6 (from my <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a>) shows how these are organized.</p>
<p><br />
 </p><div class="image">
<img src="synthlab_IWT.png" alt="synthlab_IWT.png"/>
</div>
<p> <br />
</p>
<p>Figure 9.6: (a) the sine and drum sources only store and read a single wavetable while (b) the static and dynamic sources each store an array of wavetables, one per MIDI note while (c) the WavetableDatabase contains a dictionary of IWavetableSource pointers whose keys are unique strings that name the waveforms (d) a wavetable bank is a name given to a set of wavetables used for wavetable morphing</p>
<p><b>Static Table Sources</b> <br />
 There are several static wavetable cores provided as examples:</p><ul>
<li><b>ClassicWTCore</b>: uses a StaticTableSource for each waveform</li>
<li><b>MorphWTCore</b>: uses a <b>set</b> of StaticTableSources, organized as a bank, up to 16 waveforms in size</li>
<li><b>DrumWTCore</b>: uses a DrumWTSource for each one-shot drum table</li>
</ul>
<p>When examining the sample projects, notice where the <b>statically declared wavetable sources are located</b> for each oscillator core:</p><ul>
<li><b>ClassicWTCore</b>: declares the array of sources as a member</li>
<li><b>MorphWTCore</b>: uses a <b>set</b> of StaticTableSources, declared as an array of sources for each wavetable bank structure (see MorphBankData) - the MorphWTCore owns a set of 16 MorphBankData structures, one for each of its 16 bank names</li>
<li><b>rumWTCore</b>: declares the array of sources as a member</li>
</ul>
<h2>Static Wavetables in Data Files </h2>
<p>If you plan on storing tables in a datafile (brick) on the drive somewhere, you will have a few decisions to make about how and when you access them and how you plan on creating the IWavetableSource object that will register with the database. These are going to also be very programmer-centric (or company-centric) chores. If you know before-hand (at compile time) how the file is arranged along with the number and sizes of the tables, <b>then you can consider this to be a static wavetable implementation</b> as you can pre-allocate the IWavetableSource objects statically. How you setup the datafile accesses and read operations will be up to you, but the underlying module cores will only be able to call the IWavetableSource functions and the data will need to be available for them. <br />
</p>
<p>If you do not know the contents or other "maximum" information about the data file at compile time, then you will need to use a dynamic wavetable system.</p>
<h2>Dynamic Wavetables </h2>
<p>Dynamic wavetables are data arrays that are created dynamically at or after instantiation time for the plugin. SynthLab includes a dynamic wavetable core named <b>FourierWTCore</b> that synthesizes a parabola waveform during the reset operation and whose harmonic content is related to the sample rate. This core uses the DynamicTableSource object that is designed for holding a <b>std::shared_ptr&lt;double&gt;</b> that is created during the reset operation. I am using a smart pointer here so I don't need to worry with dynamic allocation lifecycles, but you may certainly use new/delete. It is likely that your chosen method of creating and destroying the dynamic tables, and/or setting up disk accesses for a brick file will be very personalized. <br />
</p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
