<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthFunctions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___synth_functions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SynthFunctions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa2ed959a39e0b8fc1f65eb6424e1fe85"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaa2ed959a39e0b8fc1f65eb6424e1fe85">SynthLab::doLinearInterp</a> (double y1, double y2, double fractional_X)</td></tr>
<tr class="memdesc:gaa2ed959a39e0b8fc1f65eb6424e1fe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs linear interpolation of fractional x distance between two adjacent (x,y) points; returns interpolated value  <a href="group___synth_functions.html#gaa2ed959a39e0b8fc1f65eb6424e1fe85">More...</a><br /></td></tr>
<tr class="separator:gaa2ed959a39e0b8fc1f65eb6424e1fe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7edcac97d707b99911e4cd6dd4a87efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; source, std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:ga7edcac97d707b99911e4cd6dd4a87efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies an output audio buffer to an input audio buffer  <a href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">More...</a><br /></td></tr>
<tr class="separator:ga7edcac97d707b99911e4cd6dd4a87efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecaba409aa2dd92074ee74c2ac4e0870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaecaba409aa2dd92074ee74c2ac4e0870">SynthLab::copyOutputToOutput</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; source, std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:gaecaba409aa2dd92074ee74c2ac4e0870"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies an output audio buffer to another output audio buffer  <a href="group___synth_functions.html#gaecaba409aa2dd92074ee74c2ac4e0870">More...</a><br /></td></tr>
<tr class="separator:gaecaba409aa2dd92074ee74c2ac4e0870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35bd98f3125144ee6c499bdddaf830f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gab35bd98f3125144ee6c499bdddaf830f">SynthLab::copyOutputToOutput</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; source, <a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:gab35bd98f3125144ee6c499bdddaf830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies an output audio buffer to the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> audio output buffer  <a href="group___synth_functions.html#gab35bd98f3125144ee6c499bdddaf830f">More...</a><br /></td></tr>
<tr class="separator:gab35bd98f3125144ee6c499bdddaf830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152ee2a1502851aef83087fbe028e1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga152ee2a1502851aef83087fbe028e1b4">SynthLab::copyBufferToInput</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; source, std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:ga152ee2a1502851aef83087fbe028e1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies an output audio buffer to an input audio buffer  <a href="group___synth_functions.html#ga152ee2a1502851aef83087fbe028e1b4">More...</a><br /></td></tr>
<tr class="separator:ga152ee2a1502851aef83087fbe028e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8311f834e57d890e8583f8cb485b353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gac8311f834e57d890e8583f8cb485b353">SynthLab::copyAudioBufferOutputToSynthOutput</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; source, <a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:gac8311f834e57d890e8583f8cb485b353"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies an output audio buffer to the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> audio output buffer  <a href="group___synth_functions.html#gac8311f834e57d890e8583f8cb485b353">More...</a><br /></td></tr>
<tr class="separator:gac8311f834e57d890e8583f8cb485b353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2d5c2269413f1054d2c5526c360eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga8c2d5c2269413f1054d2c5526c360eb6">SynthLab::copySynthOutputToAudioBufferInput</a> (<a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;source, std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt; destination, uint32_t channel, uint32_t samplesToCopy)</td></tr>
<tr class="memdesc:ga8c2d5c2269413f1054d2c5526c360eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complementary function that moves audio from the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> output into an audio buffer.  <a href="group___synth_functions.html#ga8c2d5c2269413f1054d2c5526c360eb6">More...</a><br /></td></tr>
<tr class="separator:ga8c2d5c2269413f1054d2c5526c360eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10953a8242ca01308e31e3ada04e4f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf10953a8242ca01308e31e3ada04e4f7">SynthLab::normToLogNorm</a> (double normalizedValue)</td></tr>
<tr class="memdesc:gaf10953a8242ca01308e31e3ada04e4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalized to Log-normalized version  <a href="group___synth_functions.html#gaf10953a8242ca01308e31e3ada04e4f7">More...</a><br /></td></tr>
<tr class="separator:gaf10953a8242ca01308e31e3ada04e4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaa47512cda87e410540706923bfb45"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga1aaa47512cda87e410540706923bfb45">SynthLab::logNormToNorm</a> (double logNormalizedValue)</td></tr>
<tr class="memdesc:ga1aaa47512cda87e410540706923bfb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">log-normalized to normalized version  <a href="group___synth_functions.html#ga1aaa47512cda87e410540706923bfb45">More...</a><br /></td></tr>
<tr class="separator:ga1aaa47512cda87e410540706923bfb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1613caa8ac8321606a6a92368c5a3e3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf1613caa8ac8321606a6a92368c5a3e3">SynthLab::normToAntiLogNorm</a> (double normalizedValue)</td></tr>
<tr class="memdesc:gaf1613caa8ac8321606a6a92368c5a3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalized to anti-log normalized version  <a href="group___synth_functions.html#gaf1613caa8ac8321606a6a92368c5a3e3">More...</a><br /></td></tr>
<tr class="separator:gaf1613caa8ac8321606a6a92368c5a3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39f2dee08f9279f046e566377e7f579"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaa39f2dee08f9279f046e566377e7f579">SynthLab::antiLogNormToNorm</a> (double aLogNormalizedValue)</td></tr>
<tr class="memdesc:gaa39f2dee08f9279f046e566377e7f579"><td class="mdescLeft">&#160;</td><td class="mdescRight">anti-log normalized to normalized version  <a href="group___synth_functions.html#gaa39f2dee08f9279f046e566377e7f579">More...</a><br /></td></tr>
<tr class="separator:gaa39f2dee08f9279f046e566377e7f579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69fddc8a8a4c490560530b630e945046"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga69fddc8a8a4c490560530b630e945046">SynthLab::getModKnobValueLinear</a> (double normalizedValue, double min, double max)</td></tr>
<tr class="memdesc:ga69fddc8a8a4c490560530b630e945046"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max]  <a href="group___synth_functions.html#ga69fddc8a8a4c490560530b630e945046">More...</a><br /></td></tr>
<tr class="separator:ga69fddc8a8a4c490560530b630e945046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71011f7ef6917cb3d4551a52ce8a044"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gae71011f7ef6917cb3d4551a52ce8a044">SynthLab::getModKnobValueLog</a> (double normalizedValue, double min, double max)</td></tr>
<tr class="memdesc:gae71011f7ef6917cb3d4551a52ce8a044"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max] logarithmically  <a href="group___synth_functions.html#gae71011f7ef6917cb3d4551a52ce8a044">More...</a><br /></td></tr>
<tr class="separator:gae71011f7ef6917cb3d4551a52ce8a044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27e7f5b3d88b3128d239bf80770c871"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf27e7f5b3d88b3128d239bf80770c871">SynthLab::getModKnobValueAntiLog</a> (double normalizedValue, double min, double max)</td></tr>
<tr class="memdesc:gaf27e7f5b3d88b3128d239bf80770c871"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max] anti-logarithmically  <a href="group___synth_functions.html#gaf27e7f5b3d88b3128d239bf80770c871">More...</a><br /></td></tr>
<tr class="separator:gaf27e7f5b3d88b3128d239bf80770c871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd302e8ca73d6fc585b6af273f5213e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gadd302e8ca73d6fc585b6af273f5213e5">SynthLab::msecToSamples</a> (double sampleRate, double timeMSec)</td></tr>
<tr class="memdesc:gadd302e8ca73d6fc585b6af273f5213e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a time in milliseconds to a floating point sample count  <a href="group___synth_functions.html#gadd302e8ca73d6fc585b6af273f5213e5">More...</a><br /></td></tr>
<tr class="separator:gadd302e8ca73d6fc585b6af273f5213e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7822033cefdeb1ddac491f7a51784c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7822033cefdeb1ddac491f7a51784c37">SynthLab::clampMaxValue</a> (double &amp;value, double maxValue)</td></tr>
<tr class="memdesc:ga7822033cefdeb1ddac491f7a51784c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to max limits.  <a href="group___synth_functions.html#ga7822033cefdeb1ddac491f7a51784c37">More...</a><br /></td></tr>
<tr class="separator:ga7822033cefdeb1ddac491f7a51784c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692f0b658348879b903c01c7e6a180fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga692f0b658348879b903c01c7e6a180fb">SynthLab::clampMinValue</a> (double &amp;value, double minValue)</td></tr>
<tr class="memdesc:ga692f0b658348879b903c01c7e6a180fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to min limits.  <a href="group___synth_functions.html#ga692f0b658348879b903c01c7e6a180fb">More...</a><br /></td></tr>
<tr class="separator:ga692f0b658348879b903c01c7e6a180fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5397b0e177e87c615ead68e8d0a3e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gab5397b0e177e87c615ead68e8d0a3e9c">SynthLab::boundValue</a> (double &amp;value, double minValue, double maxValue)</td></tr>
<tr class="memdesc:gab5397b0e177e87c615ead68e8d0a3e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to min and max limits.  <a href="group___synth_functions.html#gab5397b0e177e87c615ead68e8d0a3e9c">More...</a><br /></td></tr>
<tr class="separator:gab5397b0e177e87c615ead68e8d0a3e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6cbb8f420046b3727c0d93dbbf2521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gacb6cbb8f420046b3727c0d93dbbf2521">SynthLab::boundUIntValue</a> (uint32_t &amp;value, uint32_t minValue, uint32_t maxValue)</td></tr>
<tr class="memdesc:gacb6cbb8f420046b3727c0d93dbbf2521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a uint32_t value to min and max limits.  <a href="group___synth_functions.html#gacb6cbb8f420046b3727c0d93dbbf2521">More...</a><br /></td></tr>
<tr class="separator:gacb6cbb8f420046b3727c0d93dbbf2521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464151844d0ba816cfc1cf58bd9d3570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga464151844d0ba816cfc1cf58bd9d3570">SynthLab::boundIntValue</a> (int32_t &amp;value, int32_t minValue, int32_t maxValue)</td></tr>
<tr class="memdesc:ga464151844d0ba816cfc1cf58bd9d3570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound an int32_t value to min and max limits.  <a href="group___synth_functions.html#ga464151844d0ba816cfc1cf58bd9d3570">More...</a><br /></td></tr>
<tr class="separator:ga464151844d0ba816cfc1cf58bd9d3570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dfa9a971b654f481892184b050c3127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga9dfa9a971b654f481892184b050c3127">SynthLab::boundValueUnipolar</a> (double &amp;value)</td></tr>
<tr class="memdesc:ga9dfa9a971b654f481892184b050c3127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to [0, +1].  <a href="group___synth_functions.html#ga9dfa9a971b654f481892184b050c3127">More...</a><br /></td></tr>
<tr class="separator:ga9dfa9a971b654f481892184b050c3127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41a2d49d53c24e8174c62ff3d740aa96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga41a2d49d53c24e8174c62ff3d740aa96">SynthLab::boundValueBipolar</a> (double &amp;value)</td></tr>
<tr class="memdesc:ga41a2d49d53c24e8174c62ff3d740aa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to [-1, +1].  <a href="group___synth_functions.html#ga41a2d49d53c24e8174c62ff3d740aa96">More...</a><br /></td></tr>
<tr class="separator:ga41a2d49d53c24e8174c62ff3d740aa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b4e928bd79a3e6ad19225cd80e8485d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7b4e928bd79a3e6ad19225cd80e8485d">SynthLab::boundMIDIValueByte</a> (uint32_t &amp;value)</td></tr>
<tr class="memdesc:ga7b4e928bd79a3e6ad19225cd80e8485d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to 0 and 127 limits.  <a href="group___synth_functions.html#ga7b4e928bd79a3e6ad19225cd80e8485d">More...</a><br /></td></tr>
<tr class="separator:ga7b4e928bd79a3e6ad19225cd80e8485d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7719f36490504b942636a3d1411f9b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7719f36490504b942636a3d1411f9b78">SynthLab::boundMIDIValueDoubleByte</a> (uint32_t &amp;value)</td></tr>
<tr class="memdesc:ga7719f36490504b942636a3d1411f9b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound a value to min and max limits.  <a href="group___synth_functions.html#ga7719f36490504b942636a3d1411f9b78">More...</a><br /></td></tr>
<tr class="separator:ga7719f36490504b942636a3d1411f9b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9d1697d4ad88d5fa74f6fb6f91dc572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf9d1697d4ad88d5fa74f6fb6f91dc572">SynthLab::mapDoubleValue</a> (double &amp;value, double min, double max, double minMap, double maxMap)</td></tr>
<tr class="memdesc:gaf9d1697d4ad88d5fa74f6fb6f91dc572"><td class="mdescLeft">&#160;</td><td class="mdescRight">map double on a range of (min, max) to the same double on the range of (minMap, maxMap)  <a href="group___synth_functions.html#gaf9d1697d4ad88d5fa74f6fb6f91dc572">More...</a><br /></td></tr>
<tr class="separator:gaf9d1697d4ad88d5fa74f6fb6f91dc572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6a2139754f78dc0167b3b1e7a4831c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga1e6a2139754f78dc0167b3b1e7a4831c">SynthLab::mapDoubleValue</a> (double &amp;value, double min, double minMap, double slope)</td></tr>
<tr class="memdesc:ga1e6a2139754f78dc0167b3b1e7a4831c"><td class="mdescLeft">&#160;</td><td class="mdescRight">map double on a range of (min, max) to the same double on the range of (minMap, maxMap) using a pre-calculated slope variable where:  <a href="group___synth_functions.html#ga1e6a2139754f78dc0167b3b1e7a4831c">More...</a><br /></td></tr>
<tr class="separator:ga1e6a2139754f78dc0167b3b1e7a4831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf371399c151a81deb00268473cf9cfbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf371399c151a81deb00268473cf9cfbf">SynthLab::mapIntValue</a> (int &amp;value, int min, int max, int minMap, int maxMap, bool roundValue=true)</td></tr>
<tr class="memdesc:gaf371399c151a81deb00268473cf9cfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">map int on a range of (min, max) to the same int on the range of (minMap, maxMap)  <a href="group___synth_functions.html#gaf371399c151a81deb00268473cf9cfbf">More...</a><br /></td></tr>
<tr class="separator:gaf371399c151a81deb00268473cf9cfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d438edc166d8b4a2123cf0109d5f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gac5d438edc166d8b4a2123cf0109d5f66">SynthLab::mapUintValue</a> (uint32_t &amp;value, uint32_t min, uint32_t max, uint32_t minMap, uint32_t maxMap, bool roundValue=true)</td></tr>
<tr class="memdesc:gac5d438edc166d8b4a2123cf0109d5f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">map unsigned int on a range of (min, max) to the same unsigned int on the range of (minMap, maxMap)  <a href="group___synth_functions.html#gac5d438edc166d8b4a2123cf0109d5f66">More...</a><br /></td></tr>
<tr class="separator:gac5d438edc166d8b4a2123cf0109d5f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2debfa81033d16f81954acb71028a4e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga2debfa81033d16f81954acb71028a4e6">SynthLab::mapDoubleToUINT</a> (double value, double min, double max, uint32_t minMap, uint32_t maxMap, bool roundValue=false)</td></tr>
<tr class="memdesc:ga2debfa81033d16f81954acb71028a4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">map double on a range of (min, max) to a uint32_t on the range of (minMap, maxMap)  <a href="group___synth_functions.html#ga2debfa81033d16f81954acb71028a4e6">More...</a><br /></td></tr>
<tr class="separator:ga2debfa81033d16f81954acb71028a4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga304c4e236db1b8a291a4d8a950db924f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga304c4e236db1b8a291a4d8a950db924f">SynthLab::mapUINTToDouble</a> (uint32_t value, uint32_t min, uint32_t max, double minMap, double maxMap)</td></tr>
<tr class="memdesc:ga304c4e236db1b8a291a4d8a950db924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">map uint32_t on a range of (min, max) to a double on the range of (minMap, maxMap)  <a href="group___synth_functions.html#ga304c4e236db1b8a291a4d8a950db924f">More...</a><br /></td></tr>
<tr class="separator:ga304c4e236db1b8a291a4d8a950db924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a5a59867a68935ea8423732ce1e616"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gac8a5a59867a68935ea8423732ce1e616">SynthLab::raw2dB</a> (double raw)</td></tr>
<tr class="memdesc:gac8a5a59867a68935ea8423732ce1e616"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates dB for given input  <a href="group___synth_functions.html#gac8a5a59867a68935ea8423732ce1e616">More...</a><br /></td></tr>
<tr class="separator:gac8a5a59867a68935ea8423732ce1e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe92cd4ebd07a64d83643f65ae2e4f6f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gabe92cd4ebd07a64d83643f65ae2e4f6f">SynthLab::dB2Raw</a> (double dB)</td></tr>
<tr class="memdesc:gabe92cd4ebd07a64d83643f65ae2e4f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts dB to raw value  <a href="group___synth_functions.html#gabe92cd4ebd07a64d83643f65ae2e4f6f">More...</a><br /></td></tr>
<tr class="separator:gabe92cd4ebd07a64d83643f65ae2e4f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505b24cbc78b9d27478cdd257b26e441"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga505b24cbc78b9d27478cdd257b26e441">SynthLab::peakGainFor_Q</a> (double Q)</td></tr>
<tr class="memdesc:ga505b24cbc78b9d27478cdd257b26e441"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the peak magnitude for a given Q  <a href="group___synth_functions.html#ga505b24cbc78b9d27478cdd257b26e441">More...</a><br /></td></tr>
<tr class="separator:ga505b24cbc78b9d27478cdd257b26e441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57e88ee0c88ea32115f1c6b2678b6a13"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga57e88ee0c88ea32115f1c6b2678b6a13">SynthLab::dBPeakGainFor_Q</a> (double Q)</td></tr>
<tr class="memdesc:ga57e88ee0c88ea32115f1c6b2678b6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the peak magnitude in dB for a given Q  <a href="group___synth_functions.html#ga57e88ee0c88ea32115f1c6b2678b6a13">More...</a><br /></td></tr>
<tr class="separator:ga57e88ee0c88ea32115f1c6b2678b6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3b28f1807ae94114225488cf9ba627"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga5b3b28f1807ae94114225488cf9ba627">SynthLab::sgn</a> (double xn)</td></tr>
<tr class="memdesc:ga5b3b28f1807ae94114225488cf9ba627"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates <a class="el" href="group___synth_functions.html#ga5b3b28f1807ae94114225488cf9ba627" title="calculates sgn( ) of input ">sgn( )</a> of input  <a href="group___synth_functions.html#ga5b3b28f1807ae94114225488cf9ba627">More...</a><br /></td></tr>
<tr class="separator:ga5b3b28f1807ae94114225488cf9ba627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ac525df4e848215ff0eab7fc48edf6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga68ac525df4e848215ff0eab7fc48edf6">SynthLab::calcWSGain</a> (double xn, double saturation, double asymmetry)</td></tr>
<tr class="memdesc:ga68ac525df4e848215ff0eab7fc48edf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates gain of a waveshaper  <a href="group___synth_functions.html#ga68ac525df4e848215ff0eab7fc48edf6">More...</a><br /></td></tr>
<tr class="separator:ga68ac525df4e848215ff0eab7fc48edf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0dcaa0446ee38fca4e401bd1ff5337"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga0f0dcaa0446ee38fca4e401bd1ff5337">SynthLab::atanWaveShaper</a> (double xn, double saturation)</td></tr>
<tr class="memdesc:ga0f0dcaa0446ee38fca4e401bd1ff5337"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates arctangent waveshaper  <a href="group___synth_functions.html#ga0f0dcaa0446ee38fca4e401bd1ff5337">More...</a><br /></td></tr>
<tr class="separator:ga0f0dcaa0446ee38fca4e401bd1ff5337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac299d903b051471ea3e423e9e7fc7b86"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gac299d903b051471ea3e423e9e7fc7b86">SynthLab::tanhWaveShaper</a> (double xn, double saturation)</td></tr>
<tr class="memdesc:gac299d903b051471ea3e423e9e7fc7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates hyptan waveshaper  <a href="group___synth_functions.html#gac299d903b051471ea3e423e9e7fc7b86">More...</a><br /></td></tr>
<tr class="separator:gac299d903b051471ea3e423e9e7fc7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad72501cf74a216ede2b5a1c85d9e0cdf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gad72501cf74a216ede2b5a1c85d9e0cdf">SynthLab::softClipWaveShaper</a> (double xn, double saturation)</td></tr>
<tr class="memdesc:gad72501cf74a216ede2b5a1c85d9e0cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates hyptan waveshaper  <a href="group___synth_functions.html#gad72501cf74a216ede2b5a1c85d9e0cdf">More...</a><br /></td></tr>
<tr class="separator:gad72501cf74a216ede2b5a1c85d9e0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5584d3d5bba089cc6576286712aadf4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gab5584d3d5bba089cc6576286712aadf4">SynthLab::fuzzExp1WaveShaper</a> (double xn, double saturation, double asymmetry)</td></tr>
<tr class="memdesc:gab5584d3d5bba089cc6576286712aadf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates fuzz exp1 waveshaper  <a href="group___synth_functions.html#gab5584d3d5bba089cc6576286712aadf4">More...</a><br /></td></tr>
<tr class="separator:gab5584d3d5bba089cc6576286712aadf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d92c3acddcc17f5d1f618fab8d79964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga2d92c3acddcc17f5d1f618fab8d79964">SynthLab::copyStingList</a> (std::vector&lt; std::string &gt; &amp;source, std::vector&lt; std::string &gt; &amp;destination)</td></tr>
<tr class="memdesc:ga2d92c3acddcc17f5d1f618fab8d79964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies one vector of strings to another.  <a href="group___synth_functions.html#ga2d92c3acddcc17f5d1f618fab8d79964">More...</a><br /></td></tr>
<tr class="separator:ga2d92c3acddcc17f5d1f618fab8d79964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd46a4c3e809f0020a9c3307bf7dbffe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gacd46a4c3e809f0020a9c3307bf7dbffe">SynthLab::concatStrings</a> (std::string s1, std::string s2)</td></tr>
<tr class="memdesc:gacd46a4c3e809f0020a9c3307bf7dbffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two strings.  <a href="group___synth_functions.html#gacd46a4c3e809f0020a9c3307bf7dbffe">More...</a><br /></td></tr>
<tr class="separator:gacd46a4c3e809f0020a9c3307bf7dbffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffef0c749718e40f33010b68b380fc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga6ffef0c749718e40f33010b68b380fc4">SynthLab::ReplaceSubStrWithStr</a> (std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga6ffef0c749718e40f33010b68b380fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to relace strings within a std::string object.  <a href="group___synth_functions.html#ga6ffef0c749718e40f33010b68b380fc4">More...</a><br /></td></tr>
<tr class="separator:ga6ffef0c749718e40f33010b68b380fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d66cde16b2d11bc7855d162e79108a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gae2d66cde16b2d11bc7855d162e79108a">SynthLab::stripLastFolderFromPath</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:gae2d66cde16b2d11bc7855d162e79108a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to strip the last folder path from a given path.  <a href="group___synth_functions.html#gae2d66cde16b2d11bc7855d162e79108a">More...</a><br /></td></tr>
<tr class="separator:gae2d66cde16b2d11bc7855d162e79108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573c7e4cb258d125d62583b81b74a97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga573c7e4cb258d125d62583b81b74a97f">SynthLab::getPluginContainerFolder</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ga573c7e4cb258d125d62583b81b74a97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get the outer plugin folder with the inner folder path.  <a href="group___synth_functions.html#ga573c7e4cb258d125d62583b81b74a97f">More...</a><br /></td></tr>
<tr class="separator:ga573c7e4cb258d125d62583b81b74a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73eab44609b0d8cea409be8cb93285cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga73eab44609b0d8cea409be8cb93285cb">SynthLab::doLinearInterpolation</a> (double x1, double x2, double y1, double y2, double x)</td></tr>
<tr class="memdesc:ga73eab44609b0d8cea409be8cb93285cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs linear interpolation of x distance between two (x,y) points; returns interpolated value  <a href="group___synth_functions.html#ga73eab44609b0d8cea409be8cb93285cb">More...</a><br /></td></tr>
<tr class="separator:ga73eab44609b0d8cea409be8cb93285cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac35b8e326c0330f70c0489f56631076"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaac35b8e326c0330f70c0489f56631076">SynthLab::doLinearInterpolation</a> (double y1, double y2, double fractional_X)</td></tr>
<tr class="memdesc:gaac35b8e326c0330f70c0489f56631076"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs linear interpolation of fractional x distance between two adjacent (x,y) points; returns interpolated value  <a href="group___synth_functions.html#gaac35b8e326c0330f70c0489f56631076">More...</a><br /></td></tr>
<tr class="separator:gaac35b8e326c0330f70c0489f56631076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c1d58ae75fe32346f8e87a55d95cf5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga50c1d58ae75fe32346f8e87a55d95cf5">SynthLab::doLagrangeInterpolation</a> (double *x, double *y, int n, double xbar)</td></tr>
<tr class="memdesc:ga50c1d58ae75fe32346f8e87a55d95cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements n-order Lagrange Interpolation  <a href="group___synth_functions.html#ga50c1d58ae75fe32346f8e87a55d95cf5">More...</a><br /></td></tr>
<tr class="separator:ga50c1d58ae75fe32346f8e87a55d95cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83496f88679637daacd2218f804ca641"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga83496f88679637daacd2218f804ca641">SynthLab::calculateWaveTablePhaseInc</a> (double oscFrequency, double sampleRate, uint32_t wavetableLength)</td></tr>
<tr class="memdesc:ga83496f88679637daacd2218f804ca641"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the phase-increment for a wavetable for a target oscillator frequency  <a href="group___synth_functions.html#ga83496f88679637daacd2218f804ca641">More...</a><br /></td></tr>
<tr class="separator:ga83496f88679637daacd2218f804ca641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091c7848e68088cc884d6aa565bd9d9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga091c7848e68088cc884d6aa565bd9d9a">SynthLab::checkAndWrapWaveTableIndex</a> (double &amp;index, uint32_t tableLength)</td></tr>
<tr class="memdesc:ga091c7848e68088cc884d6aa565bd9d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check and do modulo (fmod) wrap of a wavetable index value  <a href="group___synth_functions.html#ga091c7848e68088cc884d6aa565bd9d9a">More...</a><br /></td></tr>
<tr class="separator:ga091c7848e68088cc884d6aa565bd9d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5554406ff07d51ae3fbfd8d34bc0c074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga5554406ff07d51ae3fbfd8d34bc0c074">SynthLab::countTrailingZero</a> (int x)</td></tr>
<tr class="memdesc:ga5554406ff07d51ae3fbfd8d34bc0c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">count trailing zeros in a binary number  <a href="group___synth_functions.html#ga5554406ff07d51ae3fbfd8d34bc0c074">More...</a><br /></td></tr>
<tr class="separator:ga5554406ff07d51ae3fbfd8d34bc0c074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1558693f21c8ba16a2a56d7e4bb606be"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga1558693f21c8ba16a2a56d7e4bb606be">SynthLab::countTrailingZeros_x64</a> (uint64_t x)</td></tr>
<tr class="memdesc:ga1558693f21c8ba16a2a56d7e4bb606be"><td class="mdescLeft">&#160;</td><td class="mdescRight">count trailing zeros in a binary number, return in unsigned int  <a href="group___synth_functions.html#ga1558693f21c8ba16a2a56d7e4bb606be">More...</a><br /></td></tr>
<tr class="separator:ga1558693f21c8ba16a2a56d7e4bb606be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7391268e5cdc44aca13fddaae3438d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7391268e5cdc44aca13fddaae3438d36">SynthLab::calculatePanValues</a> (double bipolarModulator, double &amp;leftPanValue, double &amp;rightPanValue)</td></tr>
<tr class="memdesc:ga7391268e5cdc44aca13fddaae3438d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the left and right pan values from a bipolar (-1 -&gt; 1) value  <a href="group___synth_functions.html#ga7391268e5cdc44aca13fddaae3438d36">More...</a><br /></td></tr>
<tr class="separator:ga7391268e5cdc44aca13fddaae3438d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0da8ad7fc9d558e1c76a4eb0c84a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga8e0da8ad7fc9d558e1c76a4eb0c84a3c">SynthLab::calculateConstPwrMixValues</a> (double bipolarModulator, double &amp;mixValueA, double &amp;mixValueB)</td></tr>
<tr class="memdesc:ga8e0da8ad7fc9d558e1c76a4eb0c84a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts bipolar (-1 -&gt; 1) value into a pair of constant power mixing coefficients  <a href="group___synth_functions.html#ga8e0da8ad7fc9d558e1c76a4eb0c84a3c">More...</a><br /></td></tr>
<tr class="separator:ga8e0da8ad7fc9d558e1c76a4eb0c84a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f93ebb24fab18b0718b66a642b76b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga25f93ebb24fab18b0718b66a642b76b9">SynthLab::crossfade</a> (<a class="el" href="group___constants-_enums.html#gaa8d87ef526e311e2852bcbc66279d8e0">XFadeType</a> xfadeType, double inputA, double inputB, double xFrac)</td></tr>
<tr class="memdesc:ga25f93ebb24fab18b0718b66a642b76b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">crossfade two values And B together by some fractional amount  <a href="group___synth_functions.html#ga25f93ebb24fab18b0718b66a642b76b9">More...</a><br /></td></tr>
<tr class="separator:ga25f93ebb24fab18b0718b66a642b76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e836a7e9dd639acab240b77a90f82a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga0e836a7e9dd639acab240b77a90f82a8">SynthLab::semitonesBetweenFrequencies</a> (double startFrequency, double endFrequency)</td></tr>
<tr class="memdesc:ga0e836a7e9dd639acab240b77a90f82a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the number of semitones between a start and end frequency  <a href="group___synth_functions.html#ga0e836a7e9dd639acab240b77a90f82a8">More...</a><br /></td></tr>
<tr class="separator:ga0e836a7e9dd639acab240b77a90f82a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405eb9d7dd5f359c3e16b25510994403"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga405eb9d7dd5f359c3e16b25510994403">SynthLab::getTimeFromTempo</a> (double BPM, <a class="el" href="group___constants-_enums.html#gaf820a903f0a93c2134f826505f37ab79">NoteDuration</a> duration, bool returnMilliseconds=false)</td></tr>
<tr class="memdesc:ga405eb9d7dd5f359c3e16b25510994403"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a BPM value and a NoteDuration into a time  <a href="group___synth_functions.html#ga405eb9d7dd5f359c3e16b25510994403">More...</a><br /></td></tr>
<tr class="separator:ga405eb9d7dd5f359c3e16b25510994403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12425dd0e1ae1ee568449336daef0fa3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga12425dd0e1ae1ee568449336daef0fa3">SynthLab::getTimeFromTempo</a> (double BPM, double normalizedNoteMult)</td></tr>
<tr class="memdesc:ga12425dd0e1ae1ee568449336daef0fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a BPM value and a normalized note multiplier on the range [0, 1] to a note duration multiplier  <a href="group___synth_functions.html#ga12425dd0e1ae1ee568449336daef0fa3">More...</a><br /></td></tr>
<tr class="separator:ga12425dd0e1ae1ee568449336daef0fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace53655b3d735073f881fd156f833c18"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gace53655b3d735073f881fd156f833c18">SynthLab::quantizeBipolarValue</a> (double d, uint32_t qLevels)</td></tr>
<tr class="memdesc:gace53655b3d735073f881fd156f833c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantizes a double value into some number of quantization levels.  <a href="group___synth_functions.html#gace53655b3d735073f881fd156f833c18">More...</a><br /></td></tr>
<tr class="separator:gace53655b3d735073f881fd156f833c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d118a13e65ea9a0e54cad3356ad0bd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gab0d118a13e65ea9a0e54cad3356ad0bd">SynthLab::doubleToUint64</a> (double d)</td></tr>
<tr class="memdesc:gab0d118a13e65ea9a0e54cad3356ad0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a double value into a uint64 value without casting or mangling bits  <a href="group___synth_functions.html#gab0d118a13e65ea9a0e54cad3356ad0bd">More...</a><br /></td></tr>
<tr class="separator:gab0d118a13e65ea9a0e54cad3356ad0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded970b0c4a055fbcf646ce6a18f4ac3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaded970b0c4a055fbcf646ce6a18f4ac3">SynthLab::uint64ToDouble</a> (uint64_t u)</td></tr>
<tr class="memdesc:gaded970b0c4a055fbcf646ce6a18f4ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a uint64 value to a double value without casting or mangling bits  <a href="group___synth_functions.html#gaded970b0c4a055fbcf646ce6a18f4ac3">More...</a><br /></td></tr>
<tr class="separator:gaded970b0c4a055fbcf646ce6a18f4ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8776a307fe1e467f78e3ad54b66abd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga8b8776a307fe1e467f78e3ad54b66abd">SynthLab::floatToUint32</a> (float f)</td></tr>
<tr class="memdesc:ga8b8776a307fe1e467f78e3ad54b66abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a float value to a uint32_t value without casting or mangling bits  <a href="group___synth_functions.html#ga8b8776a307fe1e467f78e3ad54b66abd">More...</a><br /></td></tr>
<tr class="separator:ga8b8776a307fe1e467f78e3ad54b66abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8911659102ffaaf1e789c63dc553ef"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7a8911659102ffaaf1e789c63dc553ef">SynthLab::uint32ToFloat</a> (uint32_t u)</td></tr>
<tr class="memdesc:ga7a8911659102ffaaf1e789c63dc553ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a uint32_t value to a float value without casting or mangling bits  <a href="group___synth_functions.html#ga7a8911659102ffaaf1e789c63dc553ef">More...</a><br /></td></tr>
<tr class="separator:ga7a8911659102ffaaf1e789c63dc553ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3972c89cc239d11308cbb53a367a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gafd3972c89cc239d11308cbb53a367a9a">SynthLab::inRange</a> (double low, double high, double x)</td></tr>
<tr class="memdesc:gafd3972c89cc239d11308cbb53a367a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests a number to see if it is withing a certain range  <a href="group___synth_functions.html#gafd3972c89cc239d11308cbb53a367a9a">More...</a><br /></td></tr>
<tr class="separator:gafd3972c89cc239d11308cbb53a367a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23bb59f93ab650b14a5167944d148aa9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga23bb59f93ab650b14a5167944d148aa9">SynthLab::wrapMax</a> (double x, double max)</td></tr>
<tr class="memdesc:ga23bb59f93ab650b14a5167944d148aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps a value around a maximum value enough times that it falls within the maximum boundary  <a href="group___synth_functions.html#ga23bb59f93ab650b14a5167944d148aa9">More...</a><br /></td></tr>
<tr class="separator:ga23bb59f93ab650b14a5167944d148aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3630b4b825a9241168cc6ade60fed399"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga3630b4b825a9241168cc6ade60fed399">SynthLab::wrapMinMax</a> (double x, double min, double max)</td></tr>
<tr class="memdesc:ga3630b4b825a9241168cc6ade60fed399"><td class="mdescLeft">&#160;</td><td class="mdescRight">wraps a value around a maximum value enough times that it falls within the maximum boundary  <a href="group___synth_functions.html#ga3630b4b825a9241168cc6ade60fed399">More...</a><br /></td></tr>
<tr class="separator:ga3630b4b825a9241168cc6ade60fed399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a40ca60b6ec84f352961cf4ca87405c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga7a40ca60b6ec84f352961cf4ca87405c">SynthLab::charArrayToStringVector</a> (const char **charArray, uint32_t size, std::string ignoreString=&quot;&quot;)</td></tr>
<tr class="memdesc:ga7a40ca60b6ec84f352961cf4ca87405c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an old fasioned array of char* strings to a vector of std::strings.  <a href="group___synth_functions.html#ga7a40ca60b6ec84f352961cf4ca87405c">More...</a><br /></td></tr>
<tr class="separator:ga7a40ca60b6ec84f352961cf4ca87405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa294b17fd0bf966e739daa256140192b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaa294b17fd0bf966e739daa256140192b">SynthLab::appendCharArrayToStringVector</a> (const char **charArray, uint32_t size, std::vector&lt; std::string &gt; &amp;outputVector, std::string ignoreString)</td></tr>
<tr class="memdesc:gaa294b17fd0bf966e739daa256140192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends an old fasioned array of char* strings to a vector of std::strings.  <a href="group___synth_functions.html#gaa294b17fd0bf966e739daa256140192b">More...</a><br /></td></tr>
<tr class="separator:gaa294b17fd0bf966e739daa256140192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ecc2cee475b27db79c0512db5c9347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_synth_lab_1_1_vector_x_fade_data.html">VectorXFadeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga30ecc2cee475b27db79c0512db5c9347">SynthLab::calculateVectorMix</a> (double joystick_X, double joystick_Y, double origin_X=0.0, double origin_Y=0.0)</td></tr>
<tr class="memdesc:ga30ecc2cee475b27db79c0512db5c9347"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a joystick (x,y) position into the four mixing coefficients plus the X/Y axis shaodows  <a href="group___synth_functions.html#ga30ecc2cee475b27db79c0512db5c9347">More...</a><br /></td></tr>
<tr class="separator:ga30ecc2cee475b27db79c0512db5c9347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f67ddb2c3d56acfb96ff03a662a3103"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga0f67ddb2c3d56acfb96ff03a662a3103">SynthLab::quadraticSine</a> (double angle)</td></tr>
<tr class="memdesc:ga0f67ddb2c3d56acfb96ff03a662a3103"><td class="mdescLeft">&#160;</td><td class="mdescRight">produces the quadratic sine approximation  <a href="group___synth_functions.html#ga0f67ddb2c3d56acfb96ff03a662a3103">More...</a><br /></td></tr>
<tr class="separator:ga0f67ddb2c3d56acfb96ff03a662a3103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a77eccd10392a351c3f04f28d55c24b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga6a77eccd10392a351c3f04f28d55c24b">SynthLab::BhaskaraISine</a> (double angle)</td></tr>
<tr class="memdesc:ga6a77eccd10392a351c3f04f28d55c24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">produces the Bhaskara's sine approximation  <a href="group___synth_functions.html#ga6a77eccd10392a351c3f04f28d55c24b">More...</a><br /></td></tr>
<tr class="separator:ga6a77eccd10392a351c3f04f28d55c24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga837b744b9a4cf5338912bad065d7aa4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga837b744b9a4cf5338912bad065d7aa4d">SynthLab::parabolicSine</a> (double angle)</td></tr>
<tr class="memdesc:ga837b744b9a4cf5338912bad065d7aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">highest accurace sinudoid approximation function  <a href="group___synth_functions.html#ga837b744b9a4cf5338912bad065d7aa4d">More...</a><br /></td></tr>
<tr class="separator:ga837b744b9a4cf5338912bad065d7aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b656208edc2828021d48238700bf1f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga8b656208edc2828021d48238700bf1f8">SynthLab::calculatePitchBend</a> (std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_midi_input_data.html">MidiInputData</a> &gt; midiInputData)</td></tr>
<tr class="memdesc:ga8b656208edc2828021d48238700bf1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a pitch bend multiplier value based on the global MIDI input values:  <a href="group___synth_functions.html#ga8b656208edc2828021d48238700bf1f8">More...</a><br /></td></tr>
<tr class="separator:ga8b656208edc2828021d48238700bf1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a08513c4700a0e3850c44f5f2343fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gac6a08513c4700a0e3850c44f5f2343fe">SynthLab::calculateNumTables</a> (uint32_t seedMIDINote, uint32_t tableIntervalSemitones)</td></tr>
<tr class="memdesc:gac6a08513c4700a0e3850c44f5f2343fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of wavetables needed to cover the MIDI keyboard starting from a seed note, and them progressing up the keyboard by some number of semitones between each table.  <a href="group___synth_functions.html#gac6a08513c4700a0e3850c44f5f2343fe">More...</a><br /></td></tr>
<tr class="separator:gac6a08513c4700a0e3850c44f5f2343fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd11e2c88ac98a325b01f34474132d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga4fd11e2c88ac98a325b01f34474132d9">SynthLab::readHexLUT</a> (uint64_t *table, double xn)</td></tr>
<tr class="memdesc:ga4fd11e2c88ac98a325b01f34474132d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a table that has been encoded as uint64_t HEX values.  <a href="group___synth_functions.html#ga4fd11e2c88ac98a325b01f34474132d9">More...</a><br /></td></tr>
<tr class="separator:ga4fd11e2c88ac98a325b01f34474132d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3dfef7c165806dcac3e8c1903d41132"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaf3dfef7c165806dcac3e8c1903d41132">SynthLab::concaveXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:gaf3dfef7c165806dcac3e8c1903d41132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA concave tranform on a unipolar value.  <a href="group___synth_functions.html#gaf3dfef7c165806dcac3e8c1903d41132">More...</a><br /></td></tr>
<tr class="separator:gaf3dfef7c165806dcac3e8c1903d41132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fce6493c088ea77f9e0b2e3e39f891"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gab5fce6493c088ea77f9e0b2e3e39f891">SynthLab::bipolarConcaveXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:gab5fce6493c088ea77f9e0b2e3e39f891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA concave tranform on a bipolar value.  <a href="group___synth_functions.html#gab5fce6493c088ea77f9e0b2e3e39f891">More...</a><br /></td></tr>
<tr class="separator:gab5fce6493c088ea77f9e0b2e3e39f891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2e915bb3e3e4040ea3210b60f3a015"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaff2e915bb3e3e4040ea3210b60f3a015">SynthLab::reverseConcaveXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:gaff2e915bb3e3e4040ea3210b60f3a015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA reverse concave tranform on a unipolar value.  <a href="group___synth_functions.html#gaff2e915bb3e3e4040ea3210b60f3a015">More...</a><br /></td></tr>
<tr class="separator:gaff2e915bb3e3e4040ea3210b60f3a015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91666ab7975d53699c13a3a195c6d09d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga91666ab7975d53699c13a3a195c6d09d">SynthLab::bipolarReverseConcaveXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:ga91666ab7975d53699c13a3a195c6d09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA reverse concave tranform on a bipolar value.  <a href="group___synth_functions.html#ga91666ab7975d53699c13a3a195c6d09d">More...</a><br /></td></tr>
<tr class="separator:ga91666ab7975d53699c13a3a195c6d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4e2dcce3f43f905d332ad342b1df2d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga4e4e2dcce3f43f905d332ad342b1df2d">SynthLab::convexXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:ga4e4e2dcce3f43f905d332ad342b1df2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA convex tranform on a unipolar value.  <a href="group___synth_functions.html#ga4e4e2dcce3f43f905d332ad342b1df2d">More...</a><br /></td></tr>
<tr class="separator:ga4e4e2dcce3f43f905d332ad342b1df2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad820a9f3ef3c19a8954569472332d316"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gad820a9f3ef3c19a8954569472332d316">SynthLab::bipolarConvexXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:gad820a9f3ef3c19a8954569472332d316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA convex tranform on a bipolar value.  <a href="group___synth_functions.html#gad820a9f3ef3c19a8954569472332d316">More...</a><br /></td></tr>
<tr class="separator:gad820a9f3ef3c19a8954569472332d316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf2034aafa3b2733a2949d66df45008"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga9bf2034aafa3b2733a2949d66df45008">SynthLab::reverseConvexXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:ga9bf2034aafa3b2733a2949d66df45008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA reverse convex tranform on a unipolar value.  <a href="group___synth_functions.html#ga9bf2034aafa3b2733a2949d66df45008">More...</a><br /></td></tr>
<tr class="separator:ga9bf2034aafa3b2733a2949d66df45008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd47c909c67b93f369e95dded7201b64"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gafd47c909c67b93f369e95dded7201b64">SynthLab::bipolarReverseConvexXForm</a> (double xn, bool useLUT=false)</td></tr>
<tr class="memdesc:gafd47c909c67b93f369e95dded7201b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the MMA reverse convex tranform on a bipolar value.  <a href="group___synth_functions.html#gafd47c909c67b93f369e95dded7201b64">More...</a><br /></td></tr>
<tr class="separator:gafd47c909c67b93f369e95dded7201b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997fe2ce390f395d6267c6c285b6f86a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#ga997fe2ce390f395d6267c6c285b6f86a">SynthLab::doPolyBLEP_2</a> (double mcounter, double phaseInc, double height, bool risingEdge)</td></tr>
<tr class="memdesc:ga997fe2ce390f395d6267c6c285b6f86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 2nd order polynomial BLEP correction factor.  <a href="group___synth_functions.html#ga997fe2ce390f395d6267c6c285b6f86a">More...</a><br /></td></tr>
<tr class="separator:ga997fe2ce390f395d6267c6c285b6f86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52a1961b9435f191cdb6b88470d5ae9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___synth_functions.html#gaa52a1961b9435f191cdb6b88470d5ae9">SynthLab::doBLEP_N</a> (uint32_t tableLength, double modCounter, double phaseInc, double height, bool risingEdge, uint32_t pointsPerSide, bool interpolate=false)</td></tr>
<tr class="memdesc:gaa52a1961b9435f191cdb6b88470d5ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the BLEP correction factor for 1, 2, 3 or 4 points of correction on each side of the waveform discontinuity.  <a href="group___synth_functions.html#gaa52a1961b9435f191cdb6b88470d5ae9">More...</a><br /></td></tr>
<tr class="separator:gaa52a1961b9435f191cdb6b88470d5ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa39f2dee08f9279f046e566377e7f579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39f2dee08f9279f046e566377e7f579">&#9670;&nbsp;</a></span>antiLogNormToNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::antiLogNormToNorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>aLogNormalizedValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>anti-log normalized to normalized version </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aLogNormalizedValue</td><td>log-normalized value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>anti-log verion, normalized </dd></dl>

</div>
</div>
<a id="gaa294b17fd0bf966e739daa256140192b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa294b17fd0bf966e739daa256140192b">&#9670;&nbsp;</a></span>appendCharArrayToStringVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SynthLab::appendCharArrayToStringVector </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>charArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ignoreString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends an old fasioned array of char* strings to a vector of std::strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charArray</td><td>the array to append </td></tr>
    <tr><td class="paramname">size</td><td>length of array </td></tr>
    <tr><td class="paramname">outputVector</td><td>the vector to append, pass by reference </td></tr>
    <tr><td class="paramname">ignoreString</td><td>string to ignore and NOT append to the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

</div>
</div>
<a id="ga0f0dcaa0446ee38fca4e401bd1ff5337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0dcaa0446ee38fca4e401bd1ff5337">&#9670;&nbsp;</a></span>atanWaveShaper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::atanWaveShaper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates arctangent waveshaper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
    <tr><td class="paramname">saturation</td><td>the saturation control </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the waveshaped output value </dd></dl>

</div>
</div>
<a id="ga6a77eccd10392a351c3f04f28d55c24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a77eccd10392a351c3f04f28d55c24b">&#9670;&nbsp;</a></span>BhaskaraISine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::BhaskaraISine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>produces the Bhaskara's sine approximation </p>
<ul>
<li>more accurate than quadratic sine</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>sine angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bhaskara I approximation </dd></dl>

</div>
</div>
<a id="gab5fce6493c088ea77f9e0b2e3e39f891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5fce6493c088ea77f9e0b2e3e39f891">&#9670;&nbsp;</a></span>bipolarConcaveXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::bipolarConcaveXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA concave tranform on a bipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the normalized bipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convex transformed value </dd></dl>

</div>
</div>
<a id="gad820a9f3ef3c19a8954569472332d316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad820a9f3ef3c19a8954569472332d316">&#9670;&nbsp;</a></span>bipolarConvexXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::bipolarConvexXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA convex tranform on a bipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the bipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convex transformed value </dd></dl>

</div>
</div>
<a id="ga91666ab7975d53699c13a3a195c6d09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91666ab7975d53699c13a3a195c6d09d">&#9670;&nbsp;</a></span>bipolarReverseConcaveXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::bipolarReverseConcaveXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA reverse concave tranform on a bipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the bipolar bipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reverse convex transformed value </dd></dl>

</div>
</div>
<a id="gafd47c909c67b93f369e95dded7201b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd47c909c67b93f369e95dded7201b64">&#9670;&nbsp;</a></span>bipolarReverseConvexXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::bipolarReverseConvexXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA reverse convex tranform on a bipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the unipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bipolar convex transformed value </dd></dl>

</div>
</div>
<a id="ga464151844d0ba816cfc1cf58bd9d3570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464151844d0ba816cfc1cf58bd9d3570">&#9670;&nbsp;</a></span>boundIntValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundIntValue </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound an int32_t value to min and max limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be bound, pass by reference </td></tr>
    <tr><td class="paramname">minValue</td><td>minimum value of bound </td></tr>
    <tr><td class="paramname">maxValue</td><td>maximum value of bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b4e928bd79a3e6ad19225cd80e8485d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b4e928bd79a3e6ad19225cd80e8485d">&#9670;&nbsp;</a></span>boundMIDIValueByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundMIDIValueByte </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to 0 and 127 limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be bound, pass by reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7719f36490504b942636a3d1411f9b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7719f36490504b942636a3d1411f9b78">&#9670;&nbsp;</a></span>boundMIDIValueDoubleByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundMIDIValueDoubleByte </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to min and max limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be bound, pass by reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb6cbb8f420046b3727c0d93dbbf2521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6cbb8f420046b3727c0d93dbbf2521">&#9670;&nbsp;</a></span>boundUIntValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundUIntValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a uint32_t value to min and max limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
    <tr><td class="paramname">minValue</td><td>- lower bound limit </td></tr>
    <tr><td class="paramname">maxValue</td><td>- upper bound limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5397b0e177e87c615ead68e8d0a3e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5397b0e177e87c615ead68e8d0a3e9c">&#9670;&nbsp;</a></span>boundValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundValue </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to min and max limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
    <tr><td class="paramname">minValue</td><td>- lower bound limit </td></tr>
    <tr><td class="paramname">maxValue</td><td>- upper bound limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41a2d49d53c24e8174c62ff3d740aa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41a2d49d53c24e8174c62ff3d740aa96">&#9670;&nbsp;</a></span>boundValueBipolar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundValueBipolar </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to [-1, +1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9dfa9a971b654f481892184b050c3127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dfa9a971b654f481892184b050c3127">&#9670;&nbsp;</a></span>boundValueUnipolar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::boundValueUnipolar </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to [0, +1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e0da8ad7fc9d558e1c76a4eb0c84a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0da8ad7fc9d558e1c76a4eb0c84a3c">&#9670;&nbsp;</a></span>calculateConstPwrMixValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::calculateConstPwrMixValues </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bipolarModulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mixValueA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mixValueB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts bipolar (-1 -&gt; 1) value into a pair of constant power mixing coefficients </p>
<ul>
<li>returns are via pass-by-reference mechanism</li>
<li>identical to constant power pan function</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bipolarModulator</td><td>bipolar input value </td></tr>
    <tr><td class="paramname">mixValueA</td><td>returned channel A coefficient </td></tr>
    <tr><td class="paramname">mixValueB</td><td>returned channel B coefficient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6a08513c4700a0e3850c44f5f2343fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a08513c4700a0e3850c44f5f2343fe">&#9670;&nbsp;</a></span>calculateNumTables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SynthLab::calculateNumTables </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seedMIDINote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tableIntervalSemitones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the number of wavetables needed to cover the MIDI keyboard starting from a seed note, and them progressing up the keyboard by some number of semitones between each table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedMIDINote</td><td>MIDI the lowest MIDI note with a wavetable </td></tr>
    <tr><td class="paramname">tableIntervalSemitones</td><td>the interval to skip when counting tables; if this value is 1 then there will be a table on each MIDI note chromatically (semitone); if this value is 3 then there will be a table on each minor third boundary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tables needed </dd></dl>

</div>
</div>
<a id="ga7391268e5cdc44aca13fddaae3438d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7391268e5cdc44aca13fddaae3438d36">&#9670;&nbsp;</a></span>calculatePanValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::calculatePanValues </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bipolarModulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>leftPanValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>rightPanValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the left and right pan values from a bipolar (-1 -&gt; 1) value </p>
<ul>
<li>returns are via pass-by-reference mechanism</li>
<li>uses sin/cos quadrants for constant-power curve</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bipolarModulator</td><td>bipolar input value </td></tr>
    <tr><td class="paramname">leftPanValue</td><td>returned left pan multiplier </td></tr>
    <tr><td class="paramname">rightPanValue</td><td>returned right pan multiplier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b656208edc2828021d48238700bf1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b656208edc2828021d48238700bf1f8">&#9670;&nbsp;</a></span>calculatePitchBend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::calculatePitchBend </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_midi_input_data.html">MidiInputData</a> &gt;&#160;</td>
          <td class="paramname"><em>midiInputData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a pitch bend multiplier value based on the global MIDI input values: </p>
<ul>
<li>kMIDIMasterPBSensCoarse (from master controls)</li>
<li>kMIDIMasterPBSensFine (from master controls)</li>
<li>kMIDIPitchBendDataLSB (from pitch bend wheel)</li>
<li>kMIDIPitchBendDataMSB (from pitch bend wheel)</li>
<li>NOTE: the term "Master" is verbatim from the MIDI specifiction as of this writing</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">midiInputData</td><td>MIDI input data array as a shared pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pitch bend multiplier value as a double </dd></dl>

</div>
</div>
<a id="ga30ecc2cee475b27db79c0512db5c9347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ecc2cee475b27db79c0512db5c9347">&#9670;&nbsp;</a></span>calculateVectorMix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_synth_lab_1_1_vector_x_fade_data.html">VectorXFadeData</a> SynthLab::calculateVectorMix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>joystick_X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>joystick_Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>origin_X</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>origin_Y</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a joystick (x,y) position into the four mixing coefficients plus the X/Y axis shaodows </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joystick_X</td><td>joytick X coordinate </td></tr>
    <tr><td class="paramname">joystick_Y</td><td>joytick X coordinate </td></tr>
    <tr><td class="paramname">origin_X</td><td>origin of X axis </td></tr>
    <tr><td class="paramname">origin_Y</td><td>origin of Y axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_synth_lab_1_1_vector_x_fade_data.html" title="Holds mixing coefficient multipliers for the Sequential/Korg vector joystick. ">VectorXFadeData</a> structure of various vector mixing coeffients </dd></dl>

</div>
</div>
<a id="ga83496f88679637daacd2218f804ca641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83496f88679637daacd2218f804ca641">&#9670;&nbsp;</a></span>calculateWaveTablePhaseInc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::calculateWaveTablePhaseInc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oscFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wavetableLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the phase-increment for a wavetable for a target oscillator frequency </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oscFrequency</td><td>target oscillator frequency </td></tr>
    <tr><td class="paramname">sampleRate</td><td>fs </td></tr>
    <tr><td class="paramname">wavetableLength</td><td>table length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the phase-increment for a wavetable lookup </dd></dl>

</div>
</div>
<a id="ga68ac525df4e848215ff0eab7fc48edf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ac525df4e848215ff0eab7fc48edf6">&#9670;&nbsp;</a></span>calcWSGain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::calcWSGain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>asymmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates gain of a waveshaper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
    <tr><td class="paramname">saturation</td><td>the saturation control </td></tr>
    <tr><td class="paramname">asymmetry</td><td>the degree of asymmetry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gain value </dd></dl>

</div>
</div>
<a id="ga7a40ca60b6ec84f352961cf4ca87405c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a40ca60b6ec84f352961cf4ca87405c">&#9670;&nbsp;</a></span>charArrayToStringVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; SynthLab::charArrayToStringVector </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>charArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ignoreString</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an old fasioned array of char* strings to a vector of std::strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charArray</td><td>the array to convert </td></tr>
    <tr><td class="paramname">size</td><td>length of array </td></tr>
    <tr><td class="paramname">ignoreString</td><td>string to ignore and NOT add to the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the std::vector&lt;std::string&gt; version </dd></dl>

</div>
</div>
<a id="ga091c7848e68088cc884d6aa565bd9d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga091c7848e68088cc884d6aa565bd9d9a">&#9670;&nbsp;</a></span>checkAndWrapWaveTableIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SynthLab::checkAndWrapWaveTableIndex </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tableLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check and do modulo (fmod) wrap of a wavetable index value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>modulo counter value, retured with pass-by-reference </td></tr>
    <tr><td class="paramname">tableLength</td><td>wavetable length in samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the phase-increment for a wavetable lookup </dd></dl>

</div>
</div>
<a id="ga7822033cefdeb1ddac491f7a51784c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7822033cefdeb1ddac491f7a51784c37">&#9670;&nbsp;</a></span>clampMaxValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::clampMaxValue </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to max limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
    <tr><td class="paramname">maxValue</td><td>- upper bound limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga692f0b658348879b903c01c7e6a180fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga692f0b658348879b903c01c7e6a180fb">&#9670;&nbsp;</a></span>clampMinValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::clampMinValue </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound a value to min limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- value to bound </td></tr>
    <tr><td class="paramname">minValue</td><td>- lower bound limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd46a4c3e809f0020a9c3307bf7dbffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd46a4c3e809f0020a9c3307bf7dbffe">&#9670;&nbsp;</a></span>concatStrings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string SynthLab::concatStrings </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>the first string </td></tr>
    <tr><td class="paramname">s2</td><td>the second string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concatenation of the two as s1s2 </dd></dl>

</div>
</div>
<a id="gaf3dfef7c165806dcac3e8c1903d41132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3dfef7c165806dcac3e8c1903d41132">&#9670;&nbsp;</a></span>concaveXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::concaveXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA concave tranform on a unipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the normalized value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convex transformed value </dd></dl>

</div>
</div>
<a id="ga4e4e2dcce3f43f905d332ad342b1df2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e4e2dcce3f43f905d332ad342b1df2d">&#9670;&nbsp;</a></span>convexXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::convexXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA convex tranform on a unipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the unipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the convex transformed value </dd></dl>

</div>
</div>
<a id="gac8311f834e57d890e8583f8cb485b353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8311f834e57d890e8583f8cb485b353">&#9670;&nbsp;</a></span>copyAudioBufferOutputToSynthOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyAudioBufferOutputToSynthOutput </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies an output audio buffer to the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> audio output buffer </p>
<ul>
<li>functionally equivalent to <a class="el" href="group___synth_functions.html#gab35bd98f3125144ee6c499bdddaf830f" title="copies an output audio buffer to the SynthProcessInfo audio output buffer ">copyOutputToOutput( )</a>; renamed for easier programming</li>
<li>used for moving the final rendered audio data fom the engine's output mix buffers to the plugin framework-supplied buffers</li>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga152ee2a1502851aef83087fbe028e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152ee2a1502851aef83087fbe028e1b4">&#9670;&nbsp;</a></span>copyBufferToInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyBufferToInput </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies an output audio buffer to an input audio buffer </p>
<ul>
<li>functionally equivalent to <a class="el" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb" title="copies an output audio buffer to an input audio buffer ">copyOutputToInput( )</a>; renamed for easier programming</li>
<li>used for voice object to move data from its mix buffers into the rest of the audio chain</li>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose input will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7edcac97d707b99911e4cd6dd4a87efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7edcac97d707b99911e4cd6dd4a87efb">&#9670;&nbsp;</a></span>copyOutputToInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyOutputToInput </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies an output audio buffer to an input audio buffer </p>
<ul>
<li>used for moving audio data through the audio engine</li>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose input will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecaba409aa2dd92074ee74c2ac4e0870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecaba409aa2dd92074ee74c2ac4e0870">&#9670;&nbsp;</a></span>copyOutputToOutput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyOutputToOutput </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies an output audio buffer to another output audio buffer </p>
<ul>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab35bd98f3125144ee6c499bdddaf830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab35bd98f3125144ee6c499bdddaf830f">&#9670;&nbsp;</a></span>copyOutputToOutput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyOutputToOutput </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies an output audio buffer to the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> audio output buffer </p>
<ul>
<li>used for moving the final rendered audio data fom the engine's output mix buffers to the plugin framework-supplied buffers</li>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d92c3acddcc17f5d1f618fab8d79964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d92c3acddcc17f5d1f618fab8d79964">&#9670;&nbsp;</a></span>copyStingList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copyStingList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies one vector of strings to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the source vector to copy </td></tr>
    <tr><td class="paramname">destination</td><td>the vector that receives the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c2d5c2269413f1054d2c5526c360eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2d5c2269413f1054d2c5526c360eb6">&#9670;&nbsp;</a></span>copySynthOutputToAudioBufferInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::copySynthOutputToAudioBufferInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_synth_lab_1_1_synth_process_info.html">SynthProcessInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_synth_lab_1_1_audio_buffer.html">AudioBuffer</a> &gt;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>samplesToCopy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complementary function that moves audio from the <a class="el" href="class_synth_lab_1_1_synth_process_info.html" title="This structure holds all of the information needed to for the plugin framework to send MIDI informati...">SynthProcessInfo</a> output into an audio buffer. </p>
<ul>
<li>used in the plugin framework integration code</li>
<li>copies mono-&gt;mono. mono-&gt;stereo and stereo-&gt;stereo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output is being copied </td></tr>
    <tr><td class="paramname">destination</td><td><a class="el" href="class_synth_lab_1_1_audio_buffer.html" title="Encapsulates the audio buffering requirements of any module that uses audio samples for input and/or ...">AudioBuffer</a> whose output will receive the copied audio data  the channels to copy MONO_TO_MONO, MONO_TO_STEREO, STEREO_TO_STEREO </td></tr>
    <tr><td class="paramname">samplesToCopy</td><td>size of block to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5554406ff07d51ae3fbfd8d34bc0c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5554406ff07d51ae3fbfd8d34bc0c074">&#9670;&nbsp;</a></span>countTrailingZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SynthLab::countTrailingZero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>count trailing zeros in a binary number </p>
<ul>
<li><a href="https://www.geeksforgeeks.org/count-trailing-zero-bits-using-lookup-table/">https://www.geeksforgeeks.org/count-trailing-zero-bits-using-lookup-table/</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>binary numnber to count trailing zeros</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing zeros as int </dd></dl>

</div>
</div>
<a id="ga1558693f21c8ba16a2a56d7e4bb606be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1558693f21c8ba16a2a56d7e4bb606be">&#9670;&nbsp;</a></span>countTrailingZeros_x64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t SynthLab::countTrailingZeros_x64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>count trailing zeros in a binary number, return in unsigned int </p>
<ul>
<li><a href="https://www.geeksforgeeks.org/count-trailing-zero-bits-using-lookup-table/">https://www.geeksforgeeks.org/count-trailing-zero-bits-using-lookup-table/</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>binary numnber to count trailing zeros</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of trailing zeros as uint64_t </dd></dl>

</div>
</div>
<a id="ga25f93ebb24fab18b0718b66a642b76b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f93ebb24fab18b0718b66a642b76b9">&#9670;&nbsp;</a></span>crossfade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::crossfade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___constants-_enums.html#gaa8d87ef526e311e2852bcbc66279d8e0">XFadeType</a>&#160;</td>
          <td class="paramname"><em>xfadeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inputA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inputB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xFrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>crossfade two values And B together by some fractional amount </p>
<ul>
<li>frac = 0.0 is 100A</li>
<li>frac = 1.0 is 100A</li>
<li>frac = 0.5 is a 50A + 50B mixture</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xfadeType</td><td>type of crossfade: linear, square law, cosntant power </td></tr>
    <tr><td class="paramname">inputA</td><td>value A </td></tr>
    <tr><td class="paramname">inputB</td><td>value B </td></tr>
    <tr><td class="paramname">xFrac</td><td>fractional distance between them to mix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mixture of A and B </dd></dl>

</div>
</div>
<a id="gabe92cd4ebd07a64d83643f65ae2e4f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe92cd4ebd07a64d83643f65ae2e4f6f">&#9670;&nbsp;</a></span>dB2Raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::dB2Raw </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts dB to raw value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dB</td><td>value to convert to raw </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the raw value </dd></dl>

</div>
</div>
<a id="ga57e88ee0c88ea32115f1c6b2678b6a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57e88ee0c88ea32115f1c6b2678b6a13">&#9670;&nbsp;</a></span>dBPeakGainFor_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::dBPeakGainFor_Q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the peak magnitude in dB for a given Q </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>the Q value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the peak gain in dB </dd></dl>

</div>
</div>
<a id="gaa52a1961b9435f191cdb6b88470d5ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52a1961b9435f191cdb6b88470d5ae9">&#9670;&nbsp;</a></span>doBLEP_N()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doBLEP_N </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tableLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>modCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phaseInc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>risingEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pointsPerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the BLEP correction factor for 1, 2, 3 or 4 points of correction on each side of the waveform discontinuity. </p>
<ul>
<li>uses residual tables found in <a class="el" href="bleptables_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">bleptables.h</a> that have the BLEP residual encoded with a variety of windows</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableLength</td><td>lenght of the BLEP residual table </td></tr>
    <tr><td class="paramname">modCounter</td><td>the modulo counter value that is clocking the oscillator </td></tr>
    <tr><td class="paramname">phaseInc</td><td>counter's phase increment value </td></tr>
    <tr><td class="paramname">height</td><td>normalized height of the discontinuity to correction </td></tr>
    <tr><td class="paramname">risingEdge</td><td>true if discontinuity is a rising edge, false if falling edge </td></tr>
    <tr><td class="paramname">pointsPerSide</td><td>number of points per side to correct </td></tr>
    <tr><td class="paramname">interpolate</td><td>set true to interpolate BLEP tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the BLEP correction factor </dd></dl>

</div>
</div>
<a id="ga50c1d58ae75fe32346f8e87a55d95cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50c1d58ae75fe32346f8e87a55d95cf5">&#9670;&nbsp;</a></span>doLagrangeInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doLagrangeInterpolation </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xbar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implements n-order Lagrange Interpolation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to an array containing the x-coordinates of the input values </td></tr>
    <tr><td class="paramname">y</td><td>Pointer to an array containing the y-coordinates of the input values </td></tr>
    <tr><td class="paramname">n</td><td>the order of the interpolator, this is also the length of the x,y input arrays </td></tr>
    <tr><td class="paramname">xbar</td><td>The x-coorinates whose y-value we want to interpolate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated value </dd></dl>

</div>
</div>
<a id="gaa2ed959a39e0b8fc1f65eb6424e1fe85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2ed959a39e0b8fc1f65eb6424e1fe85">&#9670;&nbsp;</a></span>doLinearInterp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doLinearInterp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fractional_X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs linear interpolation of fractional x distance between two adjacent (x,y) points; returns interpolated value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y1</td><td>- the y coordinate of the first point </td></tr>
    <tr><td class="paramname">y2</td><td>- the 2 coordinate of the second point </td></tr>
    <tr><td class="paramname">fractional_X</td><td>- the interpolation location as a fractional distance between x1 and x2 (which are not needed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated value or y2 if the interpolation is outside the x interval </dd></dl>

</div>
</div>
<a id="ga73eab44609b0d8cea409be8cb93285cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73eab44609b0d8cea409be8cb93285cb">&#9670;&nbsp;</a></span>doLinearInterpolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doLinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs linear interpolation of x distance between two (x,y) points; returns interpolated value </p>
<p>NOTE** you must ensure that the x coordinates are not identical, x1 != x2 to avoid divide by zero; this code needs to be as efficient as possible So, either make sure programatically or check x1,x2 prior to calling!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the x coordinate of the first point </td></tr>
    <tr><td class="paramname">x2</td><td>the x coordinate of the second point </td></tr>
    <tr><td class="paramname">y1</td><td>the y coordinate of the first point </td></tr>
    <tr><td class="paramname">y2</td><td>the 2 coordinate of the second point </td></tr>
    <tr><td class="paramname">x</td><td>the interpolation location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated value or y1 if the x coordinates are unusable </dd></dl>

</div>
</div>
<a id="gaac35b8e326c0330f70c0489f56631076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac35b8e326c0330f70c0489f56631076">&#9670;&nbsp;</a></span>doLinearInterpolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doLinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fractional_X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs linear interpolation of fractional x distance between two adjacent (x,y) points; returns interpolated value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y1</td><td>the y coordinate of the first point </td></tr>
    <tr><td class="paramname">y2</td><td>the 2 coordinate of the second point </td></tr>
    <tr><td class="paramname">fractional_X</td><td>the interpolation location as a fractional distance between x1 and x2 (which are not needed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated value or y2 if the interpolation is outside the x interval </dd></dl>

</div>
</div>
<a id="ga997fe2ce390f395d6267c6c285b6f86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga997fe2ce390f395d6267c6c285b6f86a">&#9670;&nbsp;</a></span>doPolyBLEP_2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::doPolyBLEP_2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mcounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phaseInc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>risingEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the 2nd order polynomial BLEP correction factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcounter</td><td>the modulo counter value that is clocking the oscillator </td></tr>
    <tr><td class="paramname">phaseInc</td><td>counter's phase increment value </td></tr>
    <tr><td class="paramname">height</td><td>normalized height of the discontinuity to correction </td></tr>
    <tr><td class="paramname">risingEdge</td><td>true if discontinuity is a rising edge, false if falling edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the polyBLEP correction factor </dd></dl>

</div>
</div>
<a id="gab0d118a13e65ea9a0e54cad3356ad0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d118a13e65ea9a0e54cad3356ad0bd">&#9670;&nbsp;</a></span>doubleToUint64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t SynthLab::doubleToUint64 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a double value into a uint64 value without casting or mangling bits </p>
<ul>
<li>union for dataype conversion without bit mangling */ <br />
</li>
<li>used to store double values as 64-bit HEX strings for making tables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the double value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value, bit for bit, encoded as a uint64_t </dd></dl>

</div>
</div>
<a id="ga8b8776a307fe1e467f78e3ad54b66abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8776a307fe1e467f78e3ad54b66abd">&#9670;&nbsp;</a></span>floatToUint32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SynthLab::floatToUint32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a float value to a uint32_t value without casting or mangling bits </p>
<ul>
<li>used to store double values as 32-bit HEX strings for making tables</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the float value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value, bit for bit, encoded as a uint32_t </dd></dl>

</div>
</div>
<a id="gab5584d3d5bba089cc6576286712aadf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5584d3d5bba089cc6576286712aadf4">&#9670;&nbsp;</a></span>fuzzExp1WaveShaper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::fuzzExp1WaveShaper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>asymmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates fuzz exp1 waveshaper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
    <tr><td class="paramname">saturation</td><td>the saturation control </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the waveshaped output value </dd></dl>

</div>
</div>
<a id="gaf27e7f5b3d88b3128d239bf80770c871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27e7f5b3d88b3128d239bf80770c871">&#9670;&nbsp;</a></span>getModKnobValueAntiLog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::getModKnobValueAntiLog </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max] anti-logarithmically </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedValue</td><td>normalized value </td></tr>
    <tr><td class="paramname">min</td><td>the minimum mapped value </td></tr>
    <tr><td class="paramname">max</td><td>the maximum mapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new value, mapped on the new range anti-logarithmically </dd></dl>

</div>
</div>
<a id="ga69fddc8a8a4c490560530b630e945046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69fddc8a8a4c490560530b630e945046">&#9670;&nbsp;</a></span>getModKnobValueLinear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::getModKnobValueLinear </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedValue</td><td>normalized value </td></tr>
    <tr><td class="paramname">min</td><td>the minimum mapped value </td></tr>
    <tr><td class="paramname">max</td><td>the maximum mapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new value, mapped on the new range </dd></dl>

</div>
</div>
<a id="gae71011f7ef6917cb3d4551a52ce8a044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae71011f7ef6917cb3d4551a52ce8a044">&#9670;&nbsp;</a></span>getModKnobValueLog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::getModKnobValueLog </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a mod-knob value on the range of [0.0, 1.0] to a number on the range [min, max] logarithmically </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedValue</td><td>normalized value </td></tr>
    <tr><td class="paramname">min</td><td>the minimum mapped value </td></tr>
    <tr><td class="paramname">max</td><td>the maximum mapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new value, mapped on the new range logarithmically </dd></dl>

</div>
</div>
<a id="ga573c7e4cb258d125d62583b81b74a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573c7e4cb258d125d62583b81b74a97f">&#9670;&nbsp;</a></span>getPluginContainerFolder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::getPluginContainerFolder </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to get the outer plugin folder with the inner folder path. </p>
<ul>
<li>this assumes bundle packaging which is the same for AU, AAX, VST3, and RAFX</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to manipulate, pass-by-reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga405eb9d7dd5f359c3e16b25510994403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga405eb9d7dd5f359c3e16b25510994403">&#9670;&nbsp;</a></span>getTimeFromTempo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::getTimeFromTempo </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>BPM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___constants-_enums.html#gaf820a903f0a93c2134f826505f37ab79">NoteDuration</a>&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnMilliseconds</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a BPM value and a NoteDuration into a time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BPM</td><td>timing BPM value </td></tr>
    <tr><td class="paramname">duration</td><td>NoteDuration constant </td></tr>
    <tr><td class="paramname">returnMilliseconds</td><td>set true if you want milliseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time in seconds or milliseconds </dd></dl>

</div>
</div>
<a id="ga12425dd0e1ae1ee568449336daef0fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12425dd0e1ae1ee568449336daef0fa3">&#9670;&nbsp;</a></span>getTimeFromTempo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::getTimeFromTempo </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>BPM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedNoteMult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts a BPM value and a normalized note multiplier on the range [0, 1] to a note duration multiplier </p>
<ul>
<li>there are fewer choices with this function ranging from a whole note to a sixteenth note</li>
<li>used specifically for the mod-knobs, which transmit normalized values</li>
<li>used for the LFO's sync-to-BPM feature</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BPM</td><td>timing BPM value </td></tr>
    <tr><td class="paramname">normalizedNoteMult</td><td>normalized value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time in seconds or milliseconds </dd></dl>

</div>
</div>
<a id="gafd3972c89cc239d11308cbb53a367a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3972c89cc239d11308cbb53a367a9a">&#9670;&nbsp;</a></span>inRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SynthLab::inRange </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tests a number to see if it is withing a certain range </p>
<ul>
<li><a href="https://www.geeksforgeeks.org/how-to-check-whether-a-number-is-in-the-rangea-b-using-one-comparison">https://www.geeksforgeeks.org/how-to-check-whether-a-number-is-in-the-rangea-b-using-one-comparison</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>the minimum value of the range </td></tr>
    <tr><td class="paramname">high</td><td>the maximum value of the range </td></tr>
    <tr><td class="paramname">x</td><td>the value to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value is within the range, including endpoints </dd></dl>

</div>
</div>
<a id="ga1aaa47512cda87e410540706923bfb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aaa47512cda87e410540706923bfb45">&#9670;&nbsp;</a></span>logNormToNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::logNormToNorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logNormalizedValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>log-normalized to normalized version </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logNormalizedValue</td><td>log-normalized value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normalvalue, normalized </dd></dl>

</div>
</div>
<a id="ga2debfa81033d16f81954acb71028a4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2debfa81033d16f81954acb71028a4e6">&#9670;&nbsp;</a></span>mapDoubleToUINT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SynthLab::mapDoubleToUINT </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roundValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map double on a range of (min, max) to a uint32_t on the range of (minMap, maxMap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">max</td><td>maximum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">maxMap</td><td>maximum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">roundValue</td><td>set true to round the final value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mapped value as uint32_t </dd></dl>

</div>
</div>
<a id="gaf9d1697d4ad88d5fa74f6fb6f91dc572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9d1697d4ad88d5fa74f6fb6f91dc572">&#9670;&nbsp;</a></span>mapDoubleValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::mapDoubleValue </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map double on a range of (min, max) to the same double on the range of (minMap, maxMap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped, pass-by-reference, returns in this variable </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">max</td><td>maximum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">maxMap</td><td>maximum value of destination (mapped) range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e6a2139754f78dc0167b3b1e7a4831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6a2139754f78dc0167b3b1e7a4831c">&#9670;&nbsp;</a></span>mapDoubleValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::mapDoubleValue </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>slope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map double on a range of (min, max) to the same double on the range of (minMap, maxMap) using a pre-calculated slope variable where: </p>
<ul>
<li>slope = (maxMap - minMap) / (max - min)</li>
<li>used when the input/output mapping ranges are known apriori which is most of the time</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped, pass-by-reference, returns in this variable </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf371399c151a81deb00268473cf9cfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf371399c151a81deb00268473cf9cfbf">&#9670;&nbsp;</a></span>mapIntValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::mapIntValue </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roundValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map int on a range of (min, max) to the same int on the range of (minMap, maxMap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped, pass-by-reference, returns in this variable </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">max</td><td>maximum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">maxMap</td><td>maximum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">roundValue</td><td>set true to round the final value (crucial that you get this right for MIDI) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga304c4e236db1b8a291a4d8a950db924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga304c4e236db1b8a291a4d8a950db924f">&#9670;&nbsp;</a></span>mapUINTToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::mapUINTToDouble </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map uint32_t on a range of (min, max) to a double on the range of (minMap, maxMap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">max</td><td>maximum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">maxMap</td><td>maximum value of destination (mapped) range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mapped value as double </dd></dl>

</div>
</div>
<a id="gac5d438edc166d8b4a2123cf0109d5f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d438edc166d8b4a2123cf0109d5f66">&#9670;&nbsp;</a></span>mapUintValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::mapUintValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roundValue</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map unsigned int on a range of (min, max) to the same unsigned int on the range of (minMap, maxMap) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to be mapped, pass-by-reference, returns in this variable </td></tr>
    <tr><td class="paramname">min</td><td>minimum value of source range </td></tr>
    <tr><td class="paramname">max</td><td>maximum value of source range </td></tr>
    <tr><td class="paramname">minMap</td><td>minimum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">maxMap</td><td>maximum value of destination (mapped) range </td></tr>
    <tr><td class="paramname">roundValue</td><td>set true to round the final value (crucial that you get this right for MIDI) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd302e8ca73d6fc585b6af273f5213e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd302e8ca73d6fc585b6af273f5213e5">&#9670;&nbsp;</a></span>msecToSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::msecToSamples </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeMSec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a time in milliseconds to a floating point sample count </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>fs </td></tr>
    <tr><td class="paramname">timeMSec</td><td>time in milliseconds to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of samples (fractional) </dd></dl>

</div>
</div>
<a id="gaf1613caa8ac8321606a6a92368c5a3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1613caa8ac8321606a6a92368c5a3e3">&#9670;&nbsp;</a></span>normToAntiLogNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::normToAntiLogNorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalized to anti-log normalized version </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedValue</td><td>log-normalized value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>anti-log verion, normalized </dd></dl>

</div>
</div>
<a id="gaf10953a8242ca01308e31e3ada04e4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10953a8242ca01308e31e3ada04e4f7">&#9670;&nbsp;</a></span>normToLogNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::normToLogNorm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalizedValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalized to Log-normalized version </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normalizedValue</td><td>normalized value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log10 version, normalized </dd></dl>

</div>
</div>
<a id="ga837b744b9a4cf5338912bad065d7aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga837b744b9a4cf5338912bad065d7aa4d">&#9670;&nbsp;</a></span>parabolicSine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::parabolicSine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>highest accurace sinudoid approximation function </p>
<ul>
<li><a href="http://devmaster.net/posts/9648/fast-and-accurate-sine-cosine">http://devmaster.net/posts/9648/fast-and-accurate-sine-cosine</a> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>sine angle -pi to +pi </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga505b24cbc78b9d27478cdd257b26e441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505b24cbc78b9d27478cdd257b26e441">&#9670;&nbsp;</a></span>peakGainFor_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::peakGainFor_Q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the peak magnitude for a given Q </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>the Q value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the peak gain (not in dB) </dd></dl>

</div>
</div>
<a id="ga0f67ddb2c3d56acfb96ff03a662a3103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f67ddb2c3d56acfb96ff03a662a3103">&#9670;&nbsp;</a></span>quadraticSine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::quadraticSine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>produces the quadratic sine approximation </p>
<ul>
<li><a href="http://datagenetics.com/blog/july12019/index.html">http://datagenetics.com/blog/july12019/index.html</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>sine angle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quadratic sine approximation at the given angle </dd></dl>

</div>
</div>
<a id="gace53655b3d735073f881fd156f833c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace53655b3d735073f881fd156f833c18">&#9670;&nbsp;</a></span>quantizeBipolarValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::quantizeBipolarValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qLevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantizes a double value into some number of quantization levels. </p>
<ul>
<li>used for the step-LFO feature</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the double value to quntize </td></tr>
    <tr><td class="paramname">qLevels</td><td>number of quantization levels</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the quantized value </dd></dl>

</div>
</div>
<a id="gac8a5a59867a68935ea8423732ce1e616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8a5a59867a68935ea8423732ce1e616">&#9670;&nbsp;</a></span>raw2dB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::raw2dB </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates dB for given input </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>value to convert to dB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dB value </dd></dl>

</div>
</div>
<a id="ga4fd11e2c88ac98a325b01f34474132d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd11e2c88ac98a325b01f34474132d9">&#9670;&nbsp;</a></span>readHexLUT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::readHexLUT </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a table that has been encoded as uint64_t HEX values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>the table to read </td></tr>
    <tr><td class="paramname">xn</td><td>the fractional location within the table to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated value as a double </dd></dl>

</div>
</div>
<a id="ga6ffef0c749718e40f33010b68b380fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ffef0c749718e40f33010b68b380fc4">&#9670;&nbsp;</a></span>ReplaceSubStrWithStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::ReplaceSubStrWithStr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to relace strings within a std::string object. </p>
<ul>
<li><a href="https://stackoverflow.com/questions/2896600/how-to-replace-all-occurrences-of-a-character-in-string">https://stackoverflow.com/questions/2896600/how-to-replace-all-occurrences-of-a-character-in-string</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to manipulate, pass-by-reference </td></tr>
    <tr><td class="paramname">from</td><td>the string to find </td></tr>
    <tr><td class="paramname">to</td><td>the string to replace with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff2e915bb3e3e4040ea3210b60f3a015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2e915bb3e3e4040ea3210b60f3a015">&#9670;&nbsp;</a></span>reverseConcaveXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::reverseConcaveXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA reverse concave tranform on a unipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the unipolar bipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reverse convex transformed value </dd></dl>

</div>
</div>
<a id="ga9bf2034aafa3b2733a2949d66df45008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf2034aafa3b2733a2949d66df45008">&#9670;&nbsp;</a></span>reverseConvexXForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::reverseConvexXForm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLUT</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the MMA reverse convex tranform on a unipolar value. </p>
<ul>
<li>option to use the calculation or the lookup table (LUT)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the unipolar value to transform </td></tr>
    <tr><td class="paramname">useLUT</td><td>set to true to use lookup table instead of direct calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the reverse convex transformed value </dd></dl>

</div>
</div>
<a id="ga0e836a7e9dd639acab240b77a90f82a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e836a7e9dd639acab240b77a90f82a8">&#9670;&nbsp;</a></span>semitonesBetweenFrequencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::semitonesBetweenFrequencies </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startFrequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>endFrequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the number of semitones between a start and end frequency </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startFrequency</td><td>start frequency in Hz </td></tr>
    <tr><td class="paramname">endFrequency</td><td>end frequency in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of semitones between </dd></dl>

</div>
</div>
<a id="ga5b3b28f1807ae94114225488cf9ba627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3b28f1807ae94114225488cf9ba627">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::sgn </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates <a class="el" href="group___synth_functions.html#ga5b3b28f1807ae94114225488cf9ba627" title="calculates sgn( ) of input ">sgn( )</a> of input </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if xn is negative or +1 if xn is 0 or greater </dd></dl>

</div>
</div>
<a id="gad72501cf74a216ede2b5a1c85d9e0cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad72501cf74a216ede2b5a1c85d9e0cdf">&#9670;&nbsp;</a></span>softClipWaveShaper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::softClipWaveShaper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates hyptan waveshaper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
    <tr><td class="paramname">saturation</td><td>the saturation control </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the waveshaped output value </dd></dl>

</div>
</div>
<a id="gae2d66cde16b2d11bc7855d162e79108a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2d66cde16b2d11bc7855d162e79108a">&#9670;&nbsp;</a></span>stripLastFolderFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SynthLab::stripLastFolderFromPath </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to strip the last folder path from a given path. </p>
<ul>
<li><a href="https://stackoverflow.com/questions/10364877/c-how-to-remove-filename-from-path-string/18730891">https://stackoverflow.com/questions/10364877/c-how-to-remove-filename-from-path-string/18730891</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to manipulate, pass-by-reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac299d903b051471ea3e423e9e7fc7b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac299d903b051471ea3e423e9e7fc7b86">&#9670;&nbsp;</a></span>tanhWaveShaper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::tanhWaveShaper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>saturation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates hyptan waveshaper </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xn</td><td>the input value </td></tr>
    <tr><td class="paramname">saturation</td><td>the saturation control </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the waveshaped output value </dd></dl>

</div>
</div>
<a id="ga7a8911659102ffaaf1e789c63dc553ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8911659102ffaaf1e789c63dc553ef">&#9670;&nbsp;</a></span>uint32ToFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SynthLab::uint32ToFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a uint32_t value to a float value without casting or mangling bits </p>
<ul>
<li>used to decode double values that were stored as 32-bit HEX strings</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the uint32_t value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value, bit for bit, encoded as a float </dd></dl>

</div>
</div>
<a id="gaded970b0c4a055fbcf646ce6a18f4ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaded970b0c4a055fbcf646ce6a18f4ac3">&#9670;&nbsp;</a></span>uint64ToDouble()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::uint64ToDouble </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps a uint64 value to a double value without casting or mangling bits </p>
<ul>
<li>used to decode double values that were stored as 64-bit HEX strings</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the uint64_t value to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value, bit for bit, encoded as a double </dd></dl>

</div>
</div>
<a id="ga23bb59f93ab650b14a5167944d148aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23bb59f93ab650b14a5167944d148aa9">&#9670;&nbsp;</a></span>wrapMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::wrapMax </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wraps a value around a maximum value enough times that it falls within the maximum boundary </p>
<ul>
<li>wraps x from 0 to max</li>
<li><a href="https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi">https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to wrap </td></tr>
    <tr><td class="paramname">max</td><td>the maximum value to wrap over</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the wrapped value </dd></dl>

</div>
</div>
<a id="ga3630b4b825a9241168cc6ade60fed399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3630b4b825a9241168cc6ade60fed399">&#9670;&nbsp;</a></span>wrapMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SynthLab::wrapMinMax </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wraps a value around a maximum value enough times that it falls within the maximum boundary </p>
<ul>
<li>wraps x from min to max</li>
<li><a href="https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi">https://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to wrap </td></tr>
    <tr><td class="paramname">min</td><td>the minimum value to wrap from </td></tr>
    <tr><td class="paramname">max</td><td>the maximum value to wrap over</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the wrapped value </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
