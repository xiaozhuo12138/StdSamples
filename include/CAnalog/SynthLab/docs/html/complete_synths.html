<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthLab Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('complete_synths.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SynthLab Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The SynthLab SDK includes SynthLab projects that are described in detail in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> .Figure 1 shows the block digrams for the SynthEngine and SynthVoice Objects used in all six of the synth examples. All of these projects, as well as the example project from the programming guide here (described in <a class="el" href="voice_min_synth.html">SynthVoice Example</a> and <a class="el" href="engine_example.html">SynthEngine Example</a>) encode <b>the entire synth product inside of four files:</b></p><ul>
<li>synthengine.h and synthengine.cpp</li>
<li>synthvoice.h and synthvoice.cpp</li>
</ul>
<h2>SynthEngine is Designed for Re-Use </h2>
<p>The SynthEngine was designed to be reused from the very beginning. Its role in the synth is easily pre-defined and hard-codable. Of the two objects (voice and engine), the SynthEngine is the less specific in nature, and other than instantiating and managing its array of SynthVoice objects, it is really only involved in a couple of direct synthesis tasks:</p><ul>
<li>it assigns note-on and note-off events according to a pre-defined algorithm:</li>
<li>always use voice[0] for mono mode operation</li>
<li>always use voices[0] - [3] for unison mode operation</li>
<li>always use the built-in heuristic for voice stealing (steal the oldest playing note)</li>
<li>it accumulates the outputs of the voice objects, then routes them through audio effects, if enabled</li>
<li>the SynthLab example synths feature a built-in ping-pong delay placed on the final stereo output buss</li>
<li>the SynthEngine applies the final global volume control (named "master volume" in the MIDI spec)</li>
</ul>
<p>This means that once you get your SynthEngine up and running the way you like (and that may be right out-of-the-box), you may keep re-using the same object and plugin framework interface code without modification, over and over. Figure 1 below shows the block diagram for the SynthEngine object, as coded in the example voice and engine files.</p>
<h2>SynthVoice Defines the Synth Architecture </h2>
<p>In each of these projects, the SynthEngine object stores an array of SynthVoice objects that are identical. This makes the engine a <b>mono timbral</b> synth engine. In these examples:</p><ul>
<li>the engine responds to incoming MIDI messages on all channels alike</li>
<li>each voice renders notes from the same "patch" that is the connection of SynthModules via the modulation matrix</li>
<li>the voice controls the digital audio signal flow through its modules</li>
</ul>
<p><b>This means that a complete synth can be encoded in a single SynthVoice object</b> because the engine object does not discern between voices in its array. This means that once you have a working synth:</p><ul>
<li>you may create a centralized SynthLab SDK location, and then freely edit the SynthModules and ModuleCores within the SDK</li>
<li>as long as you adhere to the base class construction rules, the engine's databases and parameters will be safely shared via smart pointers</li>
<li>you may alter the interface objects without needing to modify any of the SDK modules, voices or engine</li>
</ul>
<p>Fun fact: <b>all six of the SynthLab example synths share the same source files, including the same synthvoice.h and synthvoice.cpp code</b> as a testament to how reusable the code really is</p><ul>
<li>this is why you only see four files in the sample code folder, two for the engine and two for the voice</li>
<li>the six example synths are discerned by a single #define statement within the compiler project; you can build all of them from the same source code files with only one line of code modfied, the #define statement</li>
</ul>
<p><b>Multi-Timbral SynthEngine</b> <br />
 You can build multi-timbral synths with the engine and voice objects as well, to mimic a Korg synth in "Combi" mode where a different patch plays on each MIDI channel, up to 16 at a time. In this case, you need to:</p><ul>
<li>make the SynthVoice object a base class for your "patch" voices</li>
<li>define different SynthVoice objects for each "patch" in your combination; one for piano, one for drums, etc...</li>
<li>change the engine object to maintain instances of each kind of voice, but still maintain a stack of SynthVoice (base class) pointers</li>
<li>change the engine's MIDI message decoding to assign different MIDI channels to different voices (patches)</li>
<li>run the rest of the engine as normal; if your voice objects adhere to the new SynthVoice base class, then the engine does not need to know anything else about them, and will call their base class functions (already declared as virtual specefically for this) as with the others</li>
<li>multi-timbral synths pose daunting GUI coding issues so this will be a major part of the project</li>
</ul>
<h2>Dynamic String Support </h2>
<p>The SynthLab projects exploit the SynthModle &lt;-&gt; ModuleCore relationship that is outlined and detailed in the <a class="el" href="synth_modules.html">SynthModule Progamming</a> and <a class="el" href="module_cores.html">ModuleCore Progamming</a> sections. This means that each module loads up to four cores, each of which implements a variation on the functionality of the module. The wavetable oscillator object WTOscillator (the SynthModule) fills up all four of its module core slots with its variations that include five ModuleCore objects: traditional wavetable, morphing wavetable, drum tables, sound FX tables, and Fourier synthesized tables. <br />
</p>
<p>You have two choices when using the SynthModules in combination with ModuleCores (remember that SynthModules may also be implemented without cores, which simplifies the GUI programming a bit but still involves the same effort of designing and implementing the operational phase methods).</p><ol type="1">
<li>assign the ModuleCores at compile time so that they are fixed; SynthModules may still expose different kinds of cores to the user but they will be hard-wired</li>
<li>use the dynamic string capabilities discussed in <a class="el" href="ex_synth_modules.html">SynthModules &amp; ModuleCores</a></li>
</ol>
<h2>Hardwired Modules &amp; Cores </h2>
<p>All of the SynthModules that load cores (which is every module except the DCA) have code written in their constructor that loads at least one core to use as the default. Some modules load more than one, adding them in sequence to their list of cores. <b>If you leave this code as-is, then the synth modules and cores are already hardwired</b>. Once set a module can't load a different core. This means for example that once you commit an oscillator to be a drum wavetable oscillator, it must remain rendering that data for the rest of the life of the synth. And, this is very much the way hardware synths operate as well.</p><ul>
<li>this means that you know the names of all of the waveforms and mod knob labels apriori while you are developing your GUI</li>
<li>you can programmatically select one of the pre-loaded cores using SynthModule::selectCore( ) at construction time</li>
<li>core[0] is the first in the list and the default</li>
<li>you can then "program" your architecture at construction time, but once set it can't change</li>
</ul>
<h2>Dynamic Modules &amp; Cores </h2>
<p>SynthLab was designed for dynamic ModuleCore loading from the very beginning. This means that you may select different cores into their owning modules at run-time, for example changing an oscillator from drum wavetables to morphing wavetables to sound effect tables. When the core changes, two other pieces of information also change:</p><ul>
<li>the module strings, which display the waveform list (oscillators), filter types (filters), or EG contours (EGs) for the user</li>
<li>the four Mod Knob labels that adorn the GUI controls, letting you know how these new controls have been assigned.</li>
</ul>
<p>The <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> details all of this, and provides the theory that underlies the modules, voice, and engine. Figure 1.3 (from the book) shows a typical GUI implementation for WTOscillator. On the right side, there are four "mod knob" controls named A, B, C and D that are specific to each module core. Most cores have at least one unassigned mod knob for you to experiment with. Examine Figure 1.3 a. and b. and notice how the GUI controls connect to the module and its cores:</p>
<ol type="1">
<li>The GUI exposes the module core names that the WTOscillator provides in a list for the user; Classic WT, etc...</li>
<li>When the user selects a core, the module strings are dynamically loaded into the next control named "Waveform" here (or "Filter Type" for the filters, or "EG Contour" for the EGs, etc...)</li>
<li>In addition, the mod knob labels (A, B, C, and D) are re-named for that particular core to show the functionality; un-assigned knobs show only the alphabetical letter</li>
<li>Each object includes four hard-wired controls that are specific to that module, for example in the oscillator object, these are tuning, output and pan controls while for the EG object, these are attack, decay, sustain and release</li>
</ol>
<p>You will see that almost all of the synth modules follow this paradigm and include exactly 10 GUI controls per module, the exceptions are the sequencer, mod matrix, FM operator and DCA that are either too complex to shoehorn into this format, or too simple to require multiple cores and GUI controls. <br />
 <br />
 </p><div class="image">
<img src="modules_2.png" alt="modules_2.png"/>
</div>
<p> <br />
</p>
<p>Figure 1.3: the WTOscillator's interface showing the relationship between module= strings, cores and mod knob strings</p>
<p>If you choose to use the dynamic string version, then you will need to make calls to the engine that will return the module core strings and mod knob labels for you to apply as a result of the user changing cores on the GUI (or automation). You will also need to know how your plugin framework handles dynamic swapping of string lists and GUI control labels. Even if you don't use ASPiK or RackAFX you can still examine the function calls and code in the sample projects available at www.willpirkle.com to see how I am dynamically changing strings around.</p>
<p><b>SynthLab Examples</b></p><ul>
<li><a class="el" href="unass_mod.html">Un-Assigned Mod Knobs</a></li>
<li><a class="el" href="common_engine.html">Engine Architecture</a></li>
<li><a class="el" href="common_voice.html">Voice Architecture</a></li>
<li><a class="el" href="six_projects.html">The Six Synth Projects</a></li>
<li><a class="el" href="common_code.html">Project Code</a></li>
<li><a class="el" href="gui_fixed.html">Fixed Module/Core &amp; GUI</a></li>
<li><a class="el" href="gui_dynamic.html">Dynamic Module/Core &amp; GUI</a></li>
<li><a class="el" href="appendix_a.html">Appendix: GUI Parameter Tables</a></li>
</ul>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
