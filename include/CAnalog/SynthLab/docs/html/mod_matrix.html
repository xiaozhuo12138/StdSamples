<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Modulation Matrix</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('mod_matrix.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Modulation Matrix </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The MinSynth object seems simple enough, and it is actually quite a small amount of code for the results you get, but the handling of the modulation values is sloppy at best. In the first iteration of MinSynth I handled modulation like this:</p><ol type="1">
<li>render the modulators</li>
<li>find the modulation output values in the object's modulation arrays</li>
<li>find the modulation input slots for the modulation receivers (destinations)</li>
<li>write the modulation output values into the appropriate slots in the modulation input arrays</li>
</ol>
<p>We also saw how intensity controls affected the modulation (Mod Knob D needs to be at 1.0 for the filter to modulate). The ModMatrix object handles these chores and once setup, requires only a single function call to its render( ) method to perform the transfer of information from the modulation sources (LFO and EG) to the modulation destinations (OSC fo and FLTER fc). The connection of a modulation source to a destination is a Modulation Routing or Mod Routing. <br />
</p>
<p>The <b>ModulationMatrix</b> object is extremely efficient; when profiling the synths, this object's <b>runModMatrix( )</b> function was always at the bottom of the CPU percentage list.</p>
<h2>Programming the Mod Matrix </h2>
<p>You program the matrix by first giving it a set of modulation sources and destinations. This is done with pointers to and from the modulation input and output arrays and is handled in fuction calls. Then, you connect the sources and destinations using optional source, channel and destination intensity controls. You can create hardwired routings that are always present, or you can add and remove routines as the user mainpulates the GUI controls. In this section, we will look at setting up the modulation matrix and creating sources, destinations and hardwired routings. First, decide on the kind of matrix the user will see.</p>
<p><b>Modulation Matrix Options</b> <br />
 The ModMatrix object can support practically any kind of modulation matrix scheme. Two common schemes are showns in Figure 14.3 from the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> here:</p>
<p><br />
 </p><div class="image">
<img src="modMatrix_1.png" alt="modMatrix_1.png"/>
</div>
<p> <br />
</p>
<p>Figure 14.3: modulation matrix designs include (a) pin/button programmable with global source and destination intensity controls and (b) a limited choice matrix with individual channel routing intensity controls</p>
<p>In Figure 14.3 (a) you can see the pin-programmable matrix that the SynthLab projects all use. All sources can be routed to all destinatons with pins that connect row and column cells. In this case, each modulation source has an intenstity control which operates on the final modulator output value, and each destination has an intesity control that governs the strength of the modulation input value. It may be easier to think of these controls as "send" (from the modulation outptu) and "receive" (into the modulation input) controls. SynthLab calles these the <b>Mod Source Intensity</b> and <b>Mod Destination Intensity</b> controls. All intensity controls have ranges from [-1.0, +1.0] where negative values will invert the modulation operation. <br />
</p>
<p>In Figure 14.3 (b) you can see another common paradigm for modulation matrix setup. Here, the user is restricted to a set number of modulation routings (4 in total). Hovever, in this case, each routing has its own intensity control. SynthLab calls this the <b>Channel Intensity</b> control for that particular routing. <br />
</p>
<p>The SynthLab ModMatrix can implement either of these paradigms, or both at once so that every modulation routing could have a source, channel, and destination intensity control. I do not use the channel intensity controls in SynthLab because I think it would be overwhelming for the user, but it is possible. Figure 14.4 from the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> is shown below. It shows the routing between a LFO's normal output (slot 0 of its modulation output array) to an oscillator's frequency modulation input (slot 3). Notice the location of the source and destination intensity controls. In this example, this routing is hardwired, and a locked path is setup with a hardwired intensity control. The user does not see these hardwired routing intensity controls. The two most common intensity setups are shown in 14.4 (b) and (c), however it is possible to have still other combinations of intensity controls.</p>
<p><br />
 </p><div class="image">
<img src="modMatrix_2.png" alt="modMatrix_2.png"/>
</div>
<p> <br />
</p>
<p>Figure 14.4: (a) the ModMatrix configuration for a single routing shows the multiple intensity controls and enable-switches; here the hardwire enable is overriding the channel branch (b) and (c) show the configurations that match Figure 14.3 (a) and (b) respectively</p>
<h2>Mod Sources/Destinations </h2>
<p>The next step is to decide on your sources and destinations. For our MinSynth, we will choose a few modulation source values (there are many more than you may think, so check the docuementation and sample code!) and choose a few modulation destination values. The LFOs are also destinations, so you can modulate one LFO with another, or even with itself! These sources and destinations will mimic the last version of MinSynth.</p>
<p><b>Modulation Sources</b> <br />
 There are two common modulation sources used in all of the SynthLab example products, plus one for the WaveSequencing synth:</p><ul>
<li>LFO normal output</li>
<li>EG normal output</li>
<li>Wave Sequencer's multi-lane outputs</li>
</ul>
<p><b>Modulation Destinations</b> <br />
 For our MinSynth, we will choose a few modulation destination values. The LFOs are also destinations, so you can modulate one LFO with another, or even with itself! Our destinations will be:</p><ul>
<li>Oscillator frequency modulation (bipolar)</li>
<li>Filter cutoff frequency modulation (bipolar)</li>
<li>DCA EG modulation (unipolar)</li>
</ul>
<p><b>Add the Object</b> <br />
 Now we'll add the modulation matrix object to the MinSynth, first adding the files to the compiler project:</p><ul>
<li><a class="el" href="modmatrix_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">modmatrix.h</a> and <a class="el" href="modmatrix_8cpp.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">modmatrix.cpp</a></li>
</ul>
<p>Next, be aware that the ModMatrix parameter structure contains functions for performing the routing and hardwiring. This is because usually, these are results of GUI manipulations and need to be set from a GUI message handler. The sequence of steps for setting up the ModMatrix object are:</p><ol type="1">
<li>create the ModMatrix; if standalone pass a nullptr for the ModMatrixParameters</li>
<li>clear the matrix arrays</li>
<li>add the sources: you give the matrix pointers to modulation source locations within each object's ModulationInput array</li>
<li>add the destinations: you give the matrix pointers to modulation destination locations within each object's ModulationOutput array</li>
<li>Add any hardwired routings; the most common is for the AmpEG -&gt; DCA EG input</li>
</ol>
<p>So, you can modify the MinSynth object with the ModMatrix and setup code:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinSynth</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="comment">// --- construct/destruct</span></div><div class="line">     <span class="comment">// &lt; removed for brevity &gt;</span></div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">     <span class="comment">// --- synth components</span></div><div class="line">     <span class="comment">// &lt; definitions removed for brevity &gt;</span></div><div class="line"></div><div class="line">     std::unique_ptr&lt;SynthLab::ModMatrix&gt; modMatrix = <span class="keyword">nullptr</span>;</div><div class="line">};</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><h2>Add Sources/Destinations &amp; Hardwired Routings </h2>
<p>Next, in the MinSynth constructor, create the ModMatrix and setup the sources, destinations, and hardwired routings. Notice how you get pointers to the input and output modulation arrays from the various components. The constants here (<b>kSourceLFO1_Norm, kDestFilter1_fc_Bipolar,</b> etc...) denote the slots in the modulation arrays and are found in <a class="el" href="synthconstants_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">synthconstants.h</a> in the <b>enum modDestination</b> and <b>enum modSource</b> enumerations. You can add as many sources and destinations as you like to these enumerations. The mod matrix array rows and columns will grow accordingly.</p>
<div class="fragment"><div class="line">MinSynth::MinSynth()</div><div class="line">{</div><div class="line">     <span class="comment">// &lt;removed smart pointer creations...&gt;</span></div><div class="line"></div><div class="line">     <span class="comment">// --- DCA</span></div><div class="line">     dca.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_d_c_a.html">SynthLab::DCA</a>( <span class="keyword">nullptr</span>, <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,                         <span class="comment">/* dca parameters */</span></div><div class="line">          blockSize));                     <span class="comment">/* block size */</span></div><div class="line"></div><div class="line">     <span class="comment">// --- mod matrix</span></div><div class="line">     modMatrix.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_mod_matrix.html">SynthLab::ModMatrix</a>(<span class="keyword">nullptr</span>));</div><div class="line"></div><div class="line">     <span class="comment">// --- clear row and columns (they are already cleared at construction; this is just good practice)</span></div><div class="line">     modMatrix-&gt;clearModMatrixArrays();</div><div class="line"></div><div class="line">     <span class="comment">// --- add the sources; note the constant definers e.g. kSourceLFO1_Norm</span></div><div class="line">     modMatrix-&gt;addModSource(SynthLab::kSourceLFO1_Norm, </div><div class="line">                             lfo-&gt;getModulationOutput()-&gt;getModArrayPtr(SynthLab::kLFONormalOutput));</div><div class="line">    </div><div class="line">     modMatrix-&gt;addModSource(SynthLab::kSourceAmpEG_Norm, </div><div class="line">                             ampEG-&gt;getModulationOutput()-&gt;getModArrayPtr(SynthLab::kEGNormalOutput));</div><div class="line"></div><div class="line">     <span class="comment">// --- add the destinations</span></div><div class="line">     modMatrix-&gt;addModDestination(SynthLab::kDestOsc1_fo, </div><div class="line">                                  wtOsc-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kBipolarMod));</div><div class="line">     </div><div class="line">     modMatrix-&gt;addModDestination(SynthLab::kDestFilter1_fc_Bipolar, </div><div class="line">                                  filter-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kBipolarMod));</div><div class="line">     </div><div class="line">     modMatrix-&gt;addModDestination(SynthLab::kDestDCA_EGMod, </div><div class="line">                                  dca-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kEGMod));</div><div class="line"></div><div class="line">     <span class="comment">// --- hardwire the routings for now; the default hardwired intenstity is 1.0</span></div><div class="line">     modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceLFO1_Norm, SynthLab::kDestOsc1_fo);</div><div class="line">     modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceLFO1_Norm, SynthLab::kDestFilter1_fc_Bipolar);</div><div class="line">     modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceAmpEG_Norm, SynthLab::kDestDCA_EGMod);</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Running the Matrix </h2>
<p>Now, we can re-write the render( ) function and remove all of the manual modulation routing code. It will all be replaced by one single function call to the ModMatrix::runModMatrix( ) method! Notice how simple and compact the resulting render code becomes.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::shared_ptr&lt;SynthLab::AudioBuffer&gt; MinSynth::render(uint32_t samplesToProcess)</div><div class="line">{</div><div class="line">     <span class="comment">// --- render LFO</span></div><div class="line">     lfo-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- render EG </span></div><div class="line">     ampEG-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- perform the modulation routings, sources to destinations</span></div><div class="line">     modMatrix-&gt;runModMatrix();</div><div class="line"></div><div class="line">     <span class="comment">// --- render oscillator</span></div><div class="line">     wtOsc-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from OSC output to filter input</span></div><div class="line">     <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a>(wtOsc-&gt;getAudioBuffers(), </div><div class="line">                                 filter-&gt;getAudioBuffers(), </div><div class="line">                                 SynthLab::STEREO_TO_STEREO, </div><div class="line">                                 blockSize);</div><div class="line"></div><div class="line">     <span class="comment">// --- render filter</span></div><div class="line">     filter-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from filter output to DCA input</span></div><div class="line">     <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a>(filter-&gt;getAudioBuffers(), </div><div class="line">                                 dca-&gt;getAudioBuffers(), </div><div class="line">                                 SynthLab::STEREO_TO_STEREO, </div><div class="line">                                 blockSize);</div><div class="line"></div><div class="line">     <span class="comment">// --- render DCA</span></div><div class="line">     dca-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- AT THIS POINT, the rendered synth audio is sitting in the DCA&#39;s AudioBuffer output array</span></div><div class="line">     <span class="keywordflow">return</span> dca-&gt;getAudioBuffers();</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Updating the ModMatrix from a GUI </h2>
<p>The ModMatrix object has multiple functions for updating its routings that are easy to use. The main thing to rememeber is that everything references the source and destination array slot constants such as <b>kSourceLFO1_Norm, kSourceAmpEG_Norm, and kDestFilter1_fc_Bipolar</b>. Notice that these define the sources and destinations, and when used as a pair of values, they define a particular modulation routing. <br />
</p>
<p><b>Modifying Intensity Controls</b> <br />
 The ModMatrix includes three intensity controls for each routing, along with a hidden hardwired intensity that is setup once and does not change. Notice that <b>you do NOT need to implement all three intensity controls</b> - in fact, you can create a mod matrix that has no intensity controls whatsoever, and use the modulator output controls (LFO output amplitude) for source intensities, and hardwire the rest. These functions are easy to understand and relatively self-explanatory. The code below would go into your update( ) function that is called as a result of GUI manipulation.</p>
<div class="fragment"><div class="line"><span class="comment">// --- get the parameter pointer</span></div><div class="line">std::shared_ptr&lt;SynthLab::ModMatrixParameters&gt; mmParameters = modMatrix-&gt;getParameters();</div><div class="line"></div><div class="line"><span class="comment">// --- EXAMPLE: setting the LFO source intensity to 0.82; normally from GUI control</span></div><div class="line">mmParameters-&gt;setMM_SourceIntensity(SynthLab::kSourceLFO1_Norm, 0.82);</div><div class="line"></div><div class="line"><span class="comment">// --- EXAMPLE: setting the OSC1 fo destination intensity to -0.9; normally from GUI control</span></div><div class="line">mmParameters-&gt;setMM_DestIntensity(SynthLab::kDestOsc1_fo, -0.9);</div><div class="line"></div><div class="line"><span class="comment">// --- EXAMPLE: set the channel intensity of the AmpEG to DCA EG Mod to 0.75</span></div><div class="line">mmParameters-&gt;setMM_ChannelIntensity(SynthLab::kSourceAmpEG_Norm, SynthLab::kDestDCA_EGMod, 0.75);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Enable/Disable Channel Routings</b> <br />
 You use the source/destination constants in pair-wise form to enable or disable a channel routing:</p>
<div class="fragment"><div class="line"><span class="comment">// --- get the parameter pointer</span></div><div class="line">std::shared_ptr&lt;SynthLab::ModMatrixParameters&gt; mmParameters = modMatrix-&gt;getParameters();</div><div class="line"></div><div class="line"><span class="comment">// --- EXAMPLE: enable (connect) the routing between LFO1 normal output and OSC1 fo; normally from GUI control</span></div><div class="line">mmParameters-&gt;setMM_ChannelEnable(SynthLab::kSourceLFO1_Norm, SynthLab::kDestOsc1_fo, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// --- EXAMPLE: disable (disconnect) the routing between LFO1 normal output and filter fc; normally from GUI control</span></div><div class="line">mmParameters-&gt;setMM_ChannelEnable(SynthLab::kSourceLFO1_Norm, SynthLab::kDestFilter1_fc_Bipolar, <span class="keyword">false</span>);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Default Destination Values</b> <br />
 Each destination has an initial value that is applied when the matrix is created - this is called the "default value." Normally, this value is 0.0 which represents no modulation. On occasion, you may want to preset the default to a non-zero value; this is often needed to prevent something from appearing to not work when the first note event occurs. You can set any destination's initial value using the simple function:</p>
<div class="fragment"><div class="line"><span class="comment">// --- set the initial value of the DCA Amp Modulation (used for tremolo) to 1.0</span></div><div class="line">parameters-&gt;modMatrixParameters-&gt;setMM_DestDefaultValue(kDestDCA_AmpMod, 1.0);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Adding or Removing Sources/Destinations During Synth Operation</b> <br />
 The ModMatrix object allows you to add or remove sources or destinations while the synth is operational, and after construction has occurred. While this is not an ordinary operation, it is still do-able using two functions to clear the routings. As with the other ModMatrix functions, the source/destination constants are used to indicate the row or column slot to clear:</p>
<div class="fragment"><div class="line"><span class="comment">// --- remove the LFO1 source</span></div><div class="line">modMatrix-&gt;clearModSource(kSourceLFO1_Norm);</div><div class="line"></div><div class="line"><span class="comment">// --- remove the filter&#39;s EG-&gt;fc destination</span></div><div class="line">modMatrix-&gt;clearModDestination(kDestFilter1_fc_EG);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Mod Destination Transforms </h2>
<p>On occasion, you will need to have the matrix apply a transform to the destination modulation value; this is often done to change the modulation from unipolar to bipolar. See the MMA DLS Level I or II specifications for more information on transforms. When you add a modulation destination, you have the option of supplying a transform constant that will automatically be applied to the final destination value. SynthLab has two built-in transforms (plus a no-transform specifier) declared in <a class="el" href="synthconstants_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">synthconstants.h</a>, and of course you may add more and modify the runModMatrix( ) function to apply them. You will find the transforms applied to the EG re-trigger modulation which must be unipolar.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> {</div><div class="line">     kNoMMTransform,      <span class="comment">/* no transform - this is the default */</span></div><div class="line">     kMMTransformBipolar, <span class="comment">/* convert destination value to bipolar */</span></div><div class="line">     kMMTransformUnipolar,<span class="comment">/* convert destination value to unipolar */</span></div><div class="line">     kNumMMTransforms</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// --- example of specifying a transform:</span></div><div class="line">modMatrix-&gt;addModDestination(kDestFilterEGRetrigger,                                      <span class="comment">/* EG re-trigger modulation */</span></div><div class="line">                             filterEG-&gt;getModulationInput()-&gt;getModArrayPtr(kTriggerMod), <span class="comment">/* pointer to array slot */</span></div><div class="line">                             kMMTransformUnipolar);                                       <span class="comment">/* make unipolar */</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Summary of ModMatrix and ModMatrixParameter Functions </h2>
<p>This table list the functions that the matrix and its parameters expose, and their usage. See the sample project code for more details and examples. <br />
</p>
<p>ModMatrix Functions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ModMatrix Function  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addModSource  </td><td class="markdownTableBodyNone">add a source, supply the modulation array index (constant) and pointer to the array   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">addModDestination  </td><td class="markdownTableBodyNone">add a destination, supply the modulation array index (constant) and pointer to the array   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clearModSource  </td><td class="markdownTableBodyNone">remove a source, supply the modulation array index (constant)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">clearModDestination  </td><td class="markdownTableBodyNone">remove a destination, supply the modulation array index (constant)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">clearModMatrixArrays  </td><td class="markdownTableBodyNone">clear all sources and destinations at once   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">runModMatrix  </td><td class="markdownTableBodyNone">run the matrix, which connects sources to destinations and applies intensity controls   </td></tr>
</table>
<p>ModMatrixParameter Functions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ModMatrixParameter Function  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setMM_SourceIntensity  </td><td class="markdownTableBodyNone">set source intensity value, supply the modulation array index (constant) and value [-1, +1]   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">setMM_DestIntensity  </td><td class="markdownTableBodyNone">set destination intensity value, supply the modulation array index (constant) and value [-1, +1]   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setMM_ChannelIntensity  </td><td class="markdownTableBodyNone">set channel intensity value, supply the source and destination modulation array indexes (constants) and value [-1, +1]   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">setMM_DestHardwireIntensity  </td><td class="markdownTableBodyNone">sets a hardwired channel intensity value, same arguments as setMM_ChannelIntensity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setMM_ChannelEnable  </td><td class="markdownTableBodyNone">enable/disable a modulation routing, same arguments as setMM_ChannelIntensity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">setMM_HardwireEnable  </td><td class="markdownTableBodyNone">enable/disable a hardwired modulation routing, same arguments as setMM_ChannelIntensity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setMM_DestDefaultValue  </td><td class="markdownTableBodyNone">set the initial default destination modulation value if non-zero   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">setMM_HardwiredRouting  </td><td class="markdownTableBodyNone">make a complete hardwired routing with source, destination and default channel intensity   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">setMM_DestHighPriority  </td><td class="markdownTableBodyNone">sets a high-priority flag for modulation routings that are not granulized (not used in SynthLab)   </td></tr>
</table>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="standalone.html">Standalone Programming</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
