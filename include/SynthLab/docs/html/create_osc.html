<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Create an Additive Oscillator Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('create_osc.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Create an Additive Oscillator Core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this module, we'll create an oscillator core object from scratch using the general purpose Oscillator object. We will use the same simple method of generating sinusoids as we used in the LFO but will use Chebychev polynomials to add harmonics in an additive synth manner. The mod knobs A, B, C, and D will control the amplitudes of the additive oscillator's first 4 harmonics above the fundamental and we will use them as if the user were manipulating a GUI (which of course you may add later using your plugin framework). <br />
</p>
<p>The first set of Chebychev polynomials is shown below. We will use T2, T3, T4 adn T5 as waveshapers to generate the harmonics from the fundemantal. <b>I am not going for efficiency here</b>, so please don't complain on your Forums or send me hate-mail. There is a method of using the results of one polynomail to generate the next and so you are welcome to research that and change the code to reflect it. <br />
</p>
<p><br />
 </p><div class="image">
<img src="chyeby.png" alt="chyeby.png"/>
</div>
<p> <br />
</p>
<p>There is a general purpose SynthModule object named Oscillator that we will use, along with its companion OscParameters data structure. It will not use wavetables or any databases. We will develop it in stages. Here are a couple of the kinds of additive waveforms it produces under our test conditions:</p>
<p><br />
 </p><div class="image">
<img src="addosc_0.png" alt="addosc_0.png"/>
</div>
<p> <br />
</p>
<h2>SynthLab Core Template </h2>
<p>The SDK contains a pair of source files that are a template for new ModuleCore development and are essentially blank starting points for any kind of core. The files are named <b>synthlabcore.h</b> and <b>synthlabcore.cpp</b> and you need to copy those files into your project and rename them (if you like) as you may be re-using these files many times in your projects. <br />
</p>
<p>For the demo project here, I have renamed them <b><a class="el" href="addosccore_8h_source.html">addosccore.h</a></b> and <b>addosccore.cpp</b> and using a text editor, I changed the class name to <b>AddOscCore</b> in both files. <br />
</p>
<p>You will need to add the following files to your project:</p><ul>
<li>oscillator.h and oscillator.cpp</li>
<li>synthlabcore.h and synthlabcore.cpp (rename if you like)</li>
</ul>
<p>The template files have everything you need to get started.</p>
<h2>SynthLab Core .h File </h2>
<p>We need to add a timebase and a MIDI pitch variable to the oscillator and we will use the SynthClock modulo counter. Add a static instance to the class declaration. The MIDI pitch value will be set during the note-on handler and will control the timebase phase increment value. Next, copy and add the Chebychev waveshaper function:</p>
<div class="fragment"><div class="line"><span class="comment">// --- member declaration in the class definition</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line"><span class="keywordtype">double</span> sampleRate = 1.0;</div><div class="line"><span class="keywordtype">double</span> midiPitch = 0.0; <span class="comment">//&lt; the midi pitch</span></div><div class="line"></div><div class="line"><span class="comment">// --- timebase</span></div><div class="line">SynthClock oscClock;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> { ChebyT2, ChebyT3, ChebyT4, ChebyT5 };</div><div class="line"></div><div class="line"><span class="comment">// --- NOT the most efficient implementation!!!!!</span></div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">double</span> doChebyWaveshaper(<span class="keywordtype">double</span> xn, uint32_t order)</div><div class="line">{</div><div class="line">     <span class="keywordtype">double</span> xSquared = xn*xn;</div><div class="line">     <span class="keywordtype">double</span> xCubed = xn*xSquared;</div><div class="line">     <span class="keywordtype">double</span> x4th = xn*xCubed;</div><div class="line">     <span class="keywordtype">double</span> x5th = xn*x4th;</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span> (order == ChebyT2)</div><div class="line">          <span class="keywordflow">return</span> (2.0 * xSquared) - 1.0;</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (order == ChebyT3)</div><div class="line">          <span class="keywordflow">return</span> (4.0 * xCubed) - (3.0 * xn);</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (order == ChebyT4)</div><div class="line">          <span class="keywordflow">return</span> (8.0 * x4th) - (8.0 * xSquared) + 1.0;</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (order == ChebyT5)</div><div class="line">          <span class="keywordflow">return</span> (16.0 * x5th) - (20.0 * xCubed) + (5.0 * xn);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> xn; <span class="comment">// not found</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>SynthLab Core .cpp File </h2>
<p>Lets hop into the Constructor and setup the waveforms. For this oscillator, we will have 2 waveforms (or patches).</p><ol type="1">
<li>sine</li>
<li>additive</li>
</ol>
<p>The mod knob labels (which you may use to remember the functionality) are: A. "Harm_2" B. "Harm_3" C. "Harm_4" D. "Harm_5"</p>
<p>Now we will step through the functions in the .cpp file, just as we did for the LFO, adding the code as needed.</p>
<p><b>Constructor: Waveform Names</b> <br />
 Open the .cpp file and change the module type, add a name and alter the waveforms and mod knobs per the plan.</p>
<div class="fragment"><div class="line">AddOscCore::AddOscCore()</div><div class="line">{</div><div class="line">     moduleType = <a class="code" href="group___constants-_enums.html#gaf6eb5737d116d3083d2f9ea3f2a46798">OSC_MODULE</a>;</div><div class="line">     moduleName = <span class="stringliteral">&quot;Add Osc&quot;</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- setup your module string here; use empty_string.c_str() for blank (empty) strings</span></div><div class="line">     coreData.moduleStrings[0] = <span class="stringliteral">&quot;sine&quot;</span>;                 coreData.moduleStrings[8] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[1] = <span class="stringliteral">&quot;additive&quot;</span>;             coreData.moduleStrings[9] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[2] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[10] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[3] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[11] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[4] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[12] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[5] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[13] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[6] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[14] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     coreData.moduleStrings[7] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();   coreData.moduleStrings[15] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line"></div><div class="line">     <span class="comment">// --- modulation control knobs</span></div><div class="line">     coreData.modKnobStrings[MOD_KNOB_A] = <span class="stringliteral">&quot;Harm_2&quot;</span>; </div><div class="line">     coreData.modKnobStrings[MOD_KNOB_B] = <span class="stringliteral">&quot;Harm_3&quot;</span>; </div><div class="line">     coreData.modKnobStrings[MOD_KNOB_C] = <span class="stringliteral">&quot;Harm_4&quot;</span>; </div><div class="line">     coreData.modKnobStrings[MOD_KNOB_D] = <span class="stringliteral">&quot;Harm_5&quot;</span>; </div><div class="line">}</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">@end</span>core</div><div class="line"></div><div class="line">__reset( )__ &lt;br&gt;</div><div class="line">For reset, ALWAYS remember to save the sample rate that is required for numerous modules and functions. </div><div class="line">- after that, we only need to rest the timebase back to its starting phase of 0.0 (the default argument value)</div><div class="line">- you can shift the phase of the clock&#39;s starting point with the argument [0.0, 1.0].</div><div class="line"></div><div class="line">@code</div><div class="line"><span class="keywordtype">bool</span> AddOscCore::reset(CoreProcData&amp; processInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- save sample rate</span></div><div class="line">     sampleRate = processInfo.sampleRate;</div><div class="line"></div><div class="line">     <span class="comment">// --- RESET OPERATIONS HERE</span></div><div class="line">     oscClock.reset();</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>update( )</b> <br />
 For the update phase, we only need to transfer the MIDI pitch value that arrived during the note-on event to set the oscillator timbase frequency. We do this here (rather than doNoteOn) because we will change this in the next module to add pitch modulation and GUI control manipulation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> AddOscCore::update(CoreProcData&amp; processInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- Get Parameters (will use in next module)</span></div><div class="line">     <span class="comment">//</span></div><div class="line">     OscParameters* parameters = <span class="keyword">static_cast&lt;</span>OscParameters*<span class="keyword">&gt;</span>(processInfo.moduleParameters);</div><div class="line"></div><div class="line">     <span class="comment">// --- UPDATE OPERATIONS HERE</span></div><div class="line">     <span class="keywordtype">double</span> pitchShift = 1.0; <span class="comment">// prepare for modulation later</span></div><div class="line"></div><div class="line">     <span class="comment">// --- calculate the moduated pitch value</span></div><div class="line">     <span class="keywordtype">double</span> oscillatorFrequency = midiPitch*pitchShift;</div><div class="line"></div><div class="line">     <span class="comment">// --- BOUND the value to our range - in theory, we would bound this to any NYQUIST</span></div><div class="line">     <a class="code" href="group___synth_functions.html#gab5397b0e177e87c615ead68e8d0a3e9c">boundValue</a>(oscillatorFrequency, <a class="code" href="group___constants-_enums.html#gab43b6935b2187a508bc30446cb727548">OSC_FMIN</a>, <a class="code" href="group___constants-_enums.html#ga4a9b30b67beb68b3c79ae4ee1fa846bd">OSC_FMAX</a>);</div><div class="line"></div><div class="line">     <span class="comment">// --- phase inc = fo/fs this sets it</span></div><div class="line">     oscClock.setFrequency(oscillatorFrequency, sampleRate);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>render( )</b> <br />
 For the render function, we need to grab the audio output buffers and go into a loop to generate the block of samples requested.</p><ul>
<li>when the user selects the "additive" patch, note how I bring down the overall amplitude of the waveform to make up for the fact that the user could max out all of the harmonic amplitude controls at 1.0</li>
<li>notice how the mod knob values are transferred from the parameter structure; this would come from a GUI control</li>
</ul>
<p>Step 1: get the audio buffer pointers and go into the block processing loop: <br />
</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> AddOscCore::render(CoreProcData&amp; processInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- Get Parameters</span></div><div class="line">     <span class="comment">//</span></div><div class="line">     OscParameters* parameters = <span class="keyword">static_cast&lt;</span>OscParameters*<span class="keyword">&gt;</span>(processInfo.moduleParameters);</div><div class="line"></div><div class="line">     <span class="comment">// --- get output buffers</span></div><div class="line">     <span class="keywordtype">float</span>* leftOutBuffer = processInfo.outputBuffers[LEFT_CHANNEL];</div><div class="line">     <span class="keywordtype">float</span>* rightOutBuffer = processInfo.outputBuffers[RIGHT_CHANNEL];</div><div class="line"></div><div class="line">     <span class="comment">// --- render additive signal</span></div><div class="line">     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; processInfo.samplesToProcess; i++)</div><div class="line">     {</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>Step 2: Start the decision tree that will decode the waveform index and generate the fundamental wavform which is needed for the others. Refer back to the LFO tutorial regarding the timebase and 2pi multiplication. <br />
 <br />
 </p><div class="fragment"><div class="line">          <span class="keywordtype">double</span> oscOutput = 0.0;</div><div class="line"></div><div class="line">          <span class="comment">// --- generate the fundamental</span></div><div class="line">          <span class="keywordtype">double</span> fund = sin(oscClock.mcounter * <a class="code" href="group___constants-_enums.html#gace28ec43173c74c9367e11c73315e09c">kTwoPi</a>);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (parameters-&gt;waveIndex == 0) <span class="comment">// fundamental only</span></div><div class="line">                    oscOutput = fund;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters-&gt;waveIndex == 1)<span class="comment">// additive</span></div><div class="line">          {</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>Step 3: For the additive code, I am first grabbing the harmonic amplitudes fromt the parameter structure; we're using the mod knobs to test with. Then, create the output for this waveform. <br />
 <br />
 </p><div class="fragment"><div class="line">               <span class="comment">// --- get the harmonic amplitudes from mod-knobs (or other GUI controls)</span></div><div class="line">               <span class="comment">//     note that the value is already on the range we desire, from 0.0 to 1.0 so there</span></div><div class="line">               <span class="comment">//     is no need to use the helper functions</span></div><div class="line">               <span class="keywordtype">double</span> h2Amp = parameters-&gt;modKnobValue[MOD_KNOB_A];</div><div class="line">               <span class="keywordtype">double</span> h3Amp = parameters-&gt;modKnobValue[MOD_KNOB_B];</div><div class="line">               <span class="keywordtype">double</span> h4Amp = parameters-&gt;modKnobValue[MOD_KNOB_C];</div><div class="line">               <span class="keywordtype">double</span> h5Amp = parameters-&gt;modKnobValue[MOD_KNOB_D];</div><div class="line">     </div><div class="line">               <span class="comment">// --- additive signal</span></div><div class="line">               oscOutput = fund + (h2Amp * doChebyWaveshaper(fund, ChebyT2))</div><div class="line">                                + (h3Amp * doChebyWaveshaper(fund, ChebyT3))</div><div class="line">                                + (h4Amp * doChebyWaveshaper(fund, ChebyT4))</div><div class="line">                                + (h5Amp * doChebyWaveshaper(fund, ChebyT5));</div><div class="line"></div><div class="line">               <span class="comment">// --- scale by -12dB to prevent clipping</span></div><div class="line">               oscOutput *= 0.25; </div><div class="line">          }</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><p>Now that the output is rendered, write to the output buffers, outside of the decision tree but inside of the block processing loop, and then advance the clock. <br />
</p>
<div class="fragment"><div class="line">          <span class="comment">// --- write out</span></div><div class="line">          leftOutBuffer[i] = oscOutput;</div><div class="line">          rightOutBuffer[i] = oscOutput;</div><div class="line"></div><div class="line">          <span class="comment">// --- advance clock and wrap if needed</span></div><div class="line">          oscClock.advanceWrapClock();</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>doNoteOn( )</b> <br />
 For this message handler we only need to store the MIDI pitch that arrives in the MIDI event structure and reset the oscillator timebase in the case that this is not the first time a note has been played. You may move this reset() function call to the note-off handler if that makes more sense to you. Note that the MIDI structure also includes the MIDI note number and velocity values [0, 127].</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">bool</span> AddOscCore::doNoteOn(CoreProcData&amp; processInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- parameters</span></div><div class="line">     midiPitch = processInfo.noteEvent.midiPitch;</div><div class="line"></div><div class="line">     <span class="comment">// --- reset timebase</span></div><div class="line">     oscClock.reset();</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Modify the Oscillator Object </h2>
<p>Now that the core is complete, we need to modify the Oscillator object to load this core at construction time. This only requires modifying the constructor to load the core. A comment has been left in the Oscillator constructor for you.</p>
<div class="fragment"><div class="line"><span class="comment">// --- need the core.h file</span></div><div class="line"><span class="preprocessor">#include &quot;addosccore.h&quot;</span></div><div class="line"></div><div class="line">Oscillator::Oscillator(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">                       std::shared_ptr&lt;OscParameters&gt; _parameters,</div><div class="line">                       uint32_t blockSize)</div><div class="line">: SynthModule(_midiInputData)</div><div class="line">, parameters(_parameters)</div><div class="line">{</div><div class="line">     <span class="comment">// --- standalone ONLY: parameters</span></div><div class="line">     <span class="keywordflow">if</span>(!parameters)</div><div class="line">          parameters.reset(<span class="keyword">new</span> OscParameters);</div><div class="line"></div><div class="line">     <span class="comment">// --- create our audio buffers</span></div><div class="line">     audioBuffers.reset(<span class="keyword">new</span> SynthProcessInfo(<a class="code" href="group___constants-_enums.html#ga353c6724238f64d1dad29158be0da0aa">OSC_INPUTS</a>, <a class="code" href="group___constants-_enums.html#ga3ccb315d3dec45c949eafb39cea0bc34">OSC_OUTPUTS</a>, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- setup the core processing structure for dynamic cores</span></div><div class="line">     coreProcessData.inputBuffers = getAudioBuffers()-&gt;getInputBuffers();</div><div class="line">     coreProcessData.outputBuffers = getAudioBuffers()-&gt;getOutputBuffers();</div><div class="line">     coreProcessData.modulationInputs = modulationInput-&gt;getModulatorPtr();</div><div class="line">     coreProcessData.modulationOutputs = modulationOutput-&gt;getModulatorPtr();</div><div class="line">     coreProcessData.moduleParameters = parameters.get();</div><div class="line">     coreProcessData.midiInputData = midiInputData-&gt;getIMIDIInputData();</div><div class="line"></div><div class="line">     <span class="comment">// --- setup the cores</span></div><div class="line">     <span class="comment">// Core 0:</span></div><div class="line">     std::shared_ptr&lt;AddOscCore&gt; additiveCore = std::make_shared&lt;AddOscCore&gt;();</div><div class="line">     addModuleCore(std::static_pointer_cast&lt;ModuleCore&gt;(additiveCore));</div><div class="line"></div><div class="line">     <span class="comment">// --- selects first core</span></div><div class="line">     selectDefaultModuleCore();</div><div class="line"></div><div class="line">}   </div><div class="line"><span class="comment">/* C-TOR */</span></div></div><!-- fragment --><h2>Testing the Oscillator and Core </h2>
<p>You have several options here and if you went through the MinSynth tutorial then you already have an obeject to test with. Regardless of how you test it, you will still need to follow the same steps. And remember that for testing I am using the mod knobs as fake GUI parameter controls for the harmonic amplitudes (another reason that they exist). Testing follows the same pattern as with the individual standalone objects, or the MinSynth voice object. <br />
</p>
<p><b>Create the Oscillator Instance</b> <br />
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;oscillator.h&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// --- an additive oscillator</span></div><div class="line">std::unique_ptr&lt;SynthLab::Oscillator&gt; addOsc = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">uint32_t blockSize = 64; <span class="comment">//&lt; make this 1 for processing single samples if that is easier for you</span></div><div class="line"></div><div class="line"><span class="comment">// --- create the smart pointer (this &quot;reset&quot; function has no relationship to the SynthModule::reset() method)</span></div><div class="line">addOsc.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_oscillator.html">SynthLab::Oscillator</a>(<span class="keyword">nullptr</span>, <span class="comment">/* MIDI input data */</span></div><div class="line">             <span class="keyword">nullptr</span>,                          <span class="comment">/* parameters */</span></div><div class="line">             blockSize));                      <span class="comment">/* process blocks (block size = 1 for processing samples instead)*/</span></div><div class="line"></div><div class="line"><span class="comment">// --- reset the object with the SynthModule method:</span></div><div class="line">addOsc-&gt;reset(44100.0); <span class="comment">//&lt; get fs from your framework</span></div><div class="line"></div><div class="line"><span class="comment">// --- select Core [0]</span></div><div class="line">addOsc-&gt;selectModuleCore(0);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Update the object for Waveform[0]</b> <br />
 There is no need to manipulate the mod knobs yet. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- setup the first test of waveform 0 (fundamental)</span></div><div class="line"><span class="comment">// --- get parameters</span></div><div class="line">std::shared_ptr&lt;SynthLab::OscParameters&gt; oscParameters = addOsc-&gt;getParameters();</div><div class="line"><span class="keywordflow">if</span> (oscParameters) <span class="comment">// should never fail</span></div><div class="line">{</div><div class="line">     <span class="comment">// --- set the variable</span></div><div class="line">     oscParameters-&gt;waveIndex = 0;</div><div class="line">     </div><div class="line">     <span class="comment">// --- call the update function (only needs to be done once per render cycle)</span></div><div class="line">     addOsc-&gt;update();</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Send a Note-On Event</b> <br />
 You can get this from a live MIDI source or fake it to test as done here. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- prepare a MIDI event for note-on</span></div><div class="line"><a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a> midiEvent;</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a> = 60;</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a7c1a0e203aa66105e2f69d3f2850881d">midiPitch</a> = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">SynthLab::midiNoteNumberToOscFrequency</a>(midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a>);</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a93dce735febfe26bc91a4b17922adec9">midiNoteVelocity</a> = 127;</div><div class="line"></div><div class="line"><span class="comment">// --- send the message</span></div><div class="line">addOsc-&gt;doNoteOn(midiEvent);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Render the Oscillator</b> <br />
 Render the oscillator and loop over the audio block for the output values. Remember that we set the blockSize variable at construction time. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- render output</span></div><div class="line">addOsc-&gt;render();</div><div class="line"></div><div class="line"><span class="comment">// --- get buffers</span></div><div class="line"><span class="keywordtype">float</span>* leftOutBuffer = addOsc-&gt;getAudioBuffers()-&gt;getOutputBuffer(SynthLab::LEFT_CHANNEL);</div><div class="line"><span class="keywordtype">float</span>* rightOutBuffer = addOsc-&gt;getAudioBuffers()-&gt;getOutputBuffer(SynthLab::RIGHT_CHANNEL);</div><div class="line"></div><div class="line"><span class="comment">// --- loop</span></div><div class="line"><span class="keywordflow">for</span> (uint32_t i = 0; i &lt; blockSize; i++)</div><div class="line">{</div><div class="line">     <span class="keywordtype">float</span> leftSample = leftOutBuffer[i];</div><div class="line">     <span class="keywordtype">float</span> rightSample = rightOutBuffer[i];</div><div class="line">     </div><div class="line">     <span class="comment">// --- send samples to your output buffer</span></div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Update the object for Waveform [1]</b> <br />
 After testing and hearing a bland sinusoid, try the 2nd waveform that is additive. Here, I am using the mod knobs for harmonic amplitudes. <br />
</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;SynthLab::OscParameters&gt; oscParameters = addOsc-&gt;getParameters();</div><div class="line"><span class="keywordflow">if</span> (oscParameters) <span class="comment">// should never fail</span></div><div class="line">{</div><div class="line">     <span class="comment">// --- set the variable</span></div><div class="line">     oscParameters-&gt;waveIndex = 1; <span class="comment">//&lt;--- additive</span></div><div class="line"></div><div class="line">     <span class="comment">// --- adjust harmonic amplitudes here</span></div><div class="line">     oscParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_A] = 0.75;</div><div class="line">     oscParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_B] = 0.5;</div><div class="line">     oscParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_C] = 0.25;</div><div class="line">     oscParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_D] = 0.5;</div><div class="line"></div><div class="line">     <span class="comment">// --- call the update function (only needs to be done once per render cycle)</span></div><div class="line">     addOsc-&gt;update();</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Testing Waveform [1]</b> <br />
 Test this oscillator waveform and you should see something like Figure 2 in your oscilloscope and spectrum analyzer showing the fundamental plus four harmonics with various amplitudes.</p>
<p><br />
 </p><div class="image">
<img src="addosc_1.png" alt="addosc_1.png"/>
</div>
<p> <br />
</p>
<p>Go back and adjust the mod knobs to see the image in Figure 3.:</p><ul>
<li>A = 1.0</li>
<li>B = 0.0</li>
<li>C = 0.0</li>
<li><p class="startli">D = 1.0</p>
<p class="startli"><br />
 </p><div class="image">
<img src="addosc_2.png" alt="addosc_2.png"/>
</div>
<p> <br />
</p>
</li>
</ul>
<h2>Add Pitch Modulation Code </h2>
<p>In the next section, we will add the pitch modulation code. You may test the oscillator connected to your LFO in the MinSynth object if you've been following the tutorials.</p>
<ul>
<li><a class="el" href="pitch_mod.html">Oscillator Pitch Modulation</a></li>
</ul>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="module_cores.html">ModuleCore Progamming</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
