<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthVoice Template Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('voice_templ.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SynthVoice Template Code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The SynthVoice template is found in the <b>synthvoice.h</b> and <b>synthvoice.cpp</b> files in the SynthLab_SDK/source/ folder.</p>
<h2>SynthVoice Operational Phases </h2>
<p>The SynthVoice Operational Phases are discussed in detail in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> and so that theory will not be repeated here. However, we do want to to step through the operational phase methods, declared as virtual in the abstract base class (at the end of this section) as these are the main interface functions that the SynthEngine will be calling. In this discussion, I will assume that your SynthVoice object either maintains and uses a set of SynthModules (as in the <a class="el" href="standalone_synth.html">Minimal Standalone Synth</a> MinSynth) or some other resources for rendering note-events, and that these resources will respond to MIDI events in some way. <br />
</p>
<h2>Construction Phase </h2>
<p>The SynthVoice tempate constructor contains argements that are shared pointers to global synth resources. In the SynthLab paradigm, the SynthEngine will create and own one of each of the resources, then pass a shared pointer to its SynthVoices during construction time.</p><ul>
<li>MIDI input (and output) data structures</li>
<li>wavetables</li>
<li>PCM samples</li>
<li>shared voice parameters</li>
</ul>
<p><b>Constructor</b> <br />
 The constructor <b>may</b> be called in stanalone mode, where all of the shared pointer arguments are <b>nullptrs</b>. In this case, the object will synthesize its own local MIDI and parameter data structures. If using SynthModules, you may choose to have the voice object create these resources, or pass those nullptrs into the modules during he constructor sequence and they will synthesize their own.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note use of shared pointers to resources</span></div><div class="line">SynthVoice(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">           std::shared_ptr&lt;MidiOutputData&gt; _midiOutputData,</div><div class="line">           std::shared_ptr&lt;SynthVoiceParameters&gt; _parameters,</div><div class="line">           std::shared_ptr&lt;WavetableDatabase&gt; _wavetableDatabase,</div><div class="line">           std::shared_ptr&lt;PCMSampleDatabase&gt; _sampleDatabase,</div><div class="line">           uint32_t _blockSize = 64);</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><p><b>Member Module Construction</b> <br />
 The constructor __may__be called in stanalone mode, where all of the shared pointer arguments are nullptr. In this case, the object will synthesize its own local version, but this will defeat the purpose of the shared pointers if you use any more than one voice object. We will see examples of SynthModule member construction in the next section. The template constructor code is simple, creating missing resources if needed and setting up the mix buffers to hold the audio output data.</p>
<div class="fragment"><div class="line"><span class="comment">// --- construction phase</span></div><div class="line">SynthVoice::SynthVoice(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">                       std::shared_ptr&lt;MidiOutputData&gt; _midiOutputData,</div><div class="line">                       std::shared_ptr&lt;SynthVoiceParameters&gt; _parameters,</div><div class="line">                       std::shared_ptr&lt;WavetableDatabase&gt; _wavetableDatabase,</div><div class="line">                       std::shared_ptr&lt;PCMSampleDatabase&gt; _sampleDatabase,</div><div class="line">                       uint32_t _blockSize)</div><div class="line">     : midiInputData(_midiInputData)        <span class="comment">//&lt;- set our midi dat interface value</span></div><div class="line">     , midiOutputData(_midiOutputData)</div><div class="line">     , parameters(_parameters)  <span class="comment">//&lt;- set our parameters</span></div><div class="line">     , wavetableDatabase(_wavetableDatabase)</div><div class="line">     , sampleDatabase(_sampleDatabase)</div><div class="line">     , blockSize(_blockSize)</div><div class="line">{</div><div class="line">     <span class="comment">// --- create if missing, standalone mode</span></div><div class="line">     <span class="keywordflow">if</span> (!midiInputData)</div><div class="line">          midiInputData.reset(<span class="keyword">new</span> (MidiInputData));</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span> (!midiInputData)</div><div class="line">          midiOutputData.reset(<span class="keyword">new</span> (MidiOutputData));</div><div class="line"> </div><div class="line">     <span class="comment">// --- this happens in stand-alone mode; does not happen otherwise;</span></div><div class="line">     <span class="comment">//     the first initialized SynthLab component creates its own parameters</span></div><div class="line">     <span class="keywordflow">if</span> (!parameters)</div><div class="line">          parameters = std::make_shared&lt;SynthVoiceParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- create your member modules here</span></div><div class="line">          </div><div class="line">          </div><div class="line">          </div><div class="line">          </div><div class="line">     <span class="comment">// --- create our audio buffers</span></div><div class="line">     mixBuffers.reset(<span class="keyword">new</span> SynthProcessInfo(<a class="code" href="group___constants-_enums.html#ga5aa686803c275f895c0f456702b01488">NO_CHANNELS</a>, STEREO_CHANNELS, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- more inits here</span></div><div class="line">     <span class="comment">//</span></div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><h2>Reset &amp; Intialize Phase </h2>
<p>For the voice object the reset phase has two parts. The first is the standard object reset that you've seen in the SynthModule and ModuleCore objects. The second is a separate function named <b>initialize</b> that is called after construction and reset have completed. This secondary intialization function brings path information to the voices. For the SynthLab example synths, this is a path to the folder that contains the DLL or plugin bundle and are listed in <a class="el" href="pcm_sample_files.html">PCM Sample Files &amp; Database</a>. However, you may changed this at the engine level, and pass whatever path you like back to the voices, which then trickle them down into the SynthModule memhers. Generally the paths are needed for retrieveing PCM samples from WAV files, but you may use it for other storage/retrieval. <br />
</p>
<p>The reset() and initialize() functions are shown below. Note that the path arrives in a const char* datatype, required for loading dynamic ModuleCores (see <a class="el" href="synth_lab_d_m.html">Creating SynthLab-DM Modules</a>) to survive function calls across the thunk barrier. In the template file, these functions are only sparsely populated. Take notice of:</p><ol type="1">
<li>the currentMIDINote number keeps track of the voice's currently playing MIDI note number, and is used for voice stealing (in the case that the note number plays a role in the stealing heuristic) as well as finding a currently playing voice to receive a note-off message; when this integer is set to -1, it indicates that no note-events have occurred yet.</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// --- reset; save sample rate</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::reset(<span class="keywordtype">double</span> _sampleRate)</div><div class="line">{</div><div class="line">     sampleRate = _sampleRate;</div><div class="line">     currentMIDINote = -1;</div><div class="line"></div><div class="line">     <span class="comment">// --- initialize sub components for new sample rate</span></div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- Initialize the voice sub-components; this really only applies to PCM oscillators that need DLL path</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::initialize(<span class="keyword">const</span> <span class="keywordtype">char</span>* dllPath)</div><div class="line">{</div><div class="line">     <span class="comment">// --- initialize all sub components that need the DLL path here</span></div><div class="line">     <span class="comment">//     it is up to you to find that path if you need it</span></div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Update Phase </h2>
<p>The update() function will be called prior to the SynthVoice::render function and for the tempate code, it is empty as there is nothing to do that invovles the template object's few member variables that pertain to voice stealing and voice state. And, since the voice's SynthModule components will be updated later, just prior to render, this function is sparse in the example project code as well. But, it will be called just prior to the SynthVoice::render method if you have any per-block variables that need to be updated or initialized.</p>
<div class="fragment"><div class="line"><span class="comment">// --- update prior to synth voice render</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::update()</div><div class="line">{</div><div class="line">     <span class="comment">// --- update your sub-components here based on the GUI parameters (if you used them)</span></div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Render Phase </h2>
<p>Referring back to the MinSynth C++ object (see <a class="el" href="standalone_synth.html">Minimal Standalone Synth</a>) you can see that the render() function is perhaps the most important as this is where the modules are manipulated to fill audio buffers with freshly synthesized data. The template code below follows the same pattern as the example synths:</p><ol type="1">
<li>flush the mix buffers old data from the last render() call</li>
<li>render audio: the missing code here would normally</li>
</ol>
<ul>
<li>render the modulators</li>
<li>render the mod matrix (if desired)</li>
<li>render the oscillator's into the mix buffer</li>
<li>push the audio data down the chain of processing modules and then into the DCA</li>
</ul>
<ol type="1">
<li>copy the mix buffer outputs (or DCA output buffers) to the SynthProcessInfo structure's buffers</li>
<li>check to see if the voice note-event has expired</li>
</ol>
<p>The last item in the list is very important. As the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> discusses, the final amp EG play a cricital role in the lifecycle of a note event. The last part of the render() function contains the code to detect if the EG has expired; if so the note event is done, if not more render operations will necessarily be called.</p>
<div class="fragment"><div class="line"><span class="comment">// --- voice render template code</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::render(SynthProcessInfo&amp; synthProcessInfo)</div><div class="line">{</div><div class="line">     <span class="comment">// --- modules require knowing the block size to render</span></div><div class="line">     uint32_t samplesToProcess = synthProcessInfo.getSamplesInBlock();</div><div class="line"></div><div class="line">     <span class="comment">// --- clear for accumulation</span></div><div class="line">     mixBuffers-&gt;flushBuffers();</div><div class="line"></div><div class="line">     <span class="comment">// --- render your objects into the mix buffer output</span></div><div class="line"></div><div class="line">     <span class="comment">// --- THE SYNTHESIS IS HERE --- //</span></div><div class="line"></div><div class="line">     <span class="comment">// --- to mains</span></div><div class="line">     <a class="code" href="group___synth_functions.html#gaecaba409aa2dd92074ee74c2ac4e0870">copyOutputToOutput</a>(mixBuffers, synthProcessInfo, STEREO_TO_STEREO, samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- check for note off condition</span></div><div class="line">     <span class="keywordflow">if</span> (voiceIsActive)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- check to see if voice has expired (final output EG has terminated)</span></div><div class="line">          <span class="comment">/* if(EG is complete)</span></div><div class="line"><span class="comment">          voiceIsActive = false; */</span></div><div class="line">     }</div><div class="line">     </div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><h2>Render Helper Functions </h2>
<p>The render operation will be manipulating AudioBuffer objects that are the outputs of oscillators and the inputs and outputs of processors. The template voice conatins an AudioBuffer to be used as a temporary mix buffer, or splitting buffer, or however you wish. The template code contains two helper functions for moving data to the mix buffers or to the final output buffers for the <a class="el" href="the_block.html">Block Audio Processing</a> SynthProcessInfo structure. One of the functions accumulates into the destination, while the other writes over the audio in the destination.</p>
<div class="fragment"><div class="line"><span class="comment">// --- acculumulate: used when mixing the outputs of parallel oscillators</span></div><div class="line"><span class="keywordtype">void</span> SynthVoice::accumulateToMixBuffer(std::shared_ptr&lt;AudioBuffer&gt; oscBuffers, uint32_t samplesInBlock, <span class="keywordtype">double</span> scaling)</div><div class="line"></div><div class="line"><span class="comment">// --- overwrite: for moving audio serially between modules</span></div><div class="line"><span class="keywordtype">void</span> SynthVoice::writeToMixBuffer(std::shared_ptr&lt;AudioBuffer&gt; oscBuffers, uint32_t samplesInBlock, <span class="keywordtype">double</span> scaling = 1.0)</div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Note On and Note Off Phase </h2>
<p>The SynthVoice shares identically prototyped functions as the SynthModules for the note-on and note-off message handlers. <br />
</p>
<p><b>doNoteOn()</b> <br />
 In this function, the MIDI note pitch is calculated for the incoming MIDI note number and the voice state member variables are reset in a ready-to-render state. In this function, you will call the same doNoteOn() functions on all of the SynthModules. For oscillators, this is also where you setup glide (portamento) modulation because the GlideModulator object will need to be started prior to rendering audio from the oscillator.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note on</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::doNoteOn(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="comment">// --- calculate MIDI -&gt; pitch value</span></div><div class="line">     <span class="keywordtype">double</span> midiPitch = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">midiNoteNumberToOscFrequency</a>(event.midiData1);</div><div class="line">     int32_t lastMIDINote = currentMIDINote;</div><div class="line">     currentMIDINote = (int32_t)event.midiData1;</div><div class="line"></div><div class="line">     MIDINoteEvent noteEvent(midiPitch, event.midiData1, event.midiData2);</div><div class="line"></div><div class="line">     <span class="comment">// --- send NOTE ON message to your sub objects here</span></div><div class="line"></div><div class="line">     <span class="comment">// --- call doNoteOn() with midiNoteEvents (a sub-set of midiEvents)</span></div><div class="line"></div><div class="line">     <span class="comment">// --- set the flag</span></div><div class="line">     voiceIsActive = <span class="keyword">true</span>; <span class="comment">// we are ON</span></div><div class="line">     voiceNoteState = voiceState::kNoteOnState;</div><div class="line"></div><div class="line">     <span class="comment">// --- this saves the midi note number and velocity so that we can identify our own note</span></div><div class="line">     voiceMIDIEvent = event;</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>doNoteOff()</b> <br />
 The majority of this function is for calling the doNoteOff() handlers on the SynthModule objects. Not much else happens here. However it is critical to call the amp EG's note off handler from this function as it dictates the lifecycle of the event.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note off</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::doNoteOff(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="comment">// --- lookup MIDI -&gt; pitch value</span></div><div class="line">     <span class="keywordtype">double</span> midiPitch = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">midiNoteNumberToOscFrequency</a>(event.midiData1);</div><div class="line"></div><div class="line">     MIDINoteEvent noteEvent(midiPitch, event.midiData1, event.midiData2);</div><div class="line"></div><div class="line">     <span class="comment">// --- send NOTE OFF message to your sub objects here</span></div><div class="line"></div><div class="line">     <span class="comment">// --- set our current state; the ampEG will determine the final state</span></div><div class="line">     voiceNoteState = voiceState::kNoteOffState;</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p><b>processMIDIEvent( )</b> <br />
 The SynthEngine will normally be the MIDI message decoder. In SynthLab, the engine splits out note-on and note-off messages and directs them to a SynthVoice object that it has chosen, either a dormant object for a new note-on event, or the currently playing voice for a note-off event. The engine will call the voice's processMIDIEvent passing note-on or note-off messages. The template function simply decodes the message and calls the proper handler on the object. For non-note events, the engine places all desired MIDI information, from CCs to global tuning values, into its MIDI input data arrays that are shared with every voice and every SynthModule so that every part of the synth has access to the MIDI input data via the shared pointer used at construction. This means that you do not ever need to pass non-note information around the objects as they all have instant access to it. In the template fuction below, note that the clearTimestamp() function is called to reset the voice timestamps; this is used in the voice stealing heuristics in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a>. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- MIDI proc function</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::processMIDIEvent(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="comment">// --- the voice only needs to process note on and off</span></div><div class="line">     <span class="comment">//     Other MIDI info such as CC can be found in global midi table via our midiData interface</span></div><div class="line">     <span class="keywordflow">if</span> (event.midiMessage == NOTE_ON)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- clear timestamp</span></div><div class="line">          clearTimestamp();</div><div class="line"></div><div class="line">          <span class="comment">// --- call the subfunction</span></div><div class="line">          doNoteOn(event);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (event.midiMessage == <a class="code" href="group___constants-_enums.html#gad5684fb99f8aa7c7895227dada53d244">NOTE_OFF</a>)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- call the subfunction</span></div><div class="line">          doNoteOff(event);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p>This completes the tour of the template object. In the next section, we will convert the MinSynth C++ object into a SynthVoice, to be used with a mono SynthEngine we will design and implement in the <a class="el" href="the_engine.html">SynthEngine Object</a>.</p>
<h2>Abstract SynthVoice Base Class </h2>
<p>If you want the functionality of the voice within the SynthEngine paradigm, but you want to write your own implementations, use this abstract base class version to subclass your object. You will need to implement the abstract virtual functions. The remaining functions and variables handle queries from the SynthEngine's MIDI message handler. If you do not intend on using the Engine's MIDI messaging, the you may delete them.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SynthVoice</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     SynthVoice(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">                std::shared_ptr&lt;MidiOutputData&gt; _midiOutputData,</div><div class="line">                std::shared_ptr&lt;SynthVoiceParameters&gt; _parameters,</div><div class="line">                std::shared_ptr&lt;WavetableDatabase&gt; _wavetableDatabase,</div><div class="line">                std::shared_ptr&lt;PCMSampleDatabase&gt; _sampleDatabase,</div><div class="line">                uint32_t _blockSize = 64);</div><div class="line"></div><div class="line">     <span class="keyword">virtual</span> ~SynthVoice() {} </div><div class="line"></div><div class="line">     <span class="comment">// --- abstract base class overrides</span></div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> reset(<span class="keywordtype">double</span> _sampleRate) = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> update() = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> render(SynthProcessInfo&amp; synthProcessInfo) = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> processMIDIEvent(midiEvent&amp; event) = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> initialize(<span class="keyword">const</span> <span class="keywordtype">char</span>* dllPath = <span class="keyword">nullptr</span>) = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> doNoteOn(midiEvent&amp; event) = 0;</div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> doNoteOff(midiEvent&amp; event) = 0;</div><div class="line">     </div><div class="line">     <span class="comment">// --- functions that the engine calls, but refer only to local attributes</span></div><div class="line">     <span class="keywordtype">bool</span> isVoiceActive() { <span class="keywordflow">return</span> voiceIsActive; }</div><div class="line">     voiceState getVoiceState() { <span class="keywordflow">return</span> voiceNoteState; }</div><div class="line">     uint32_t getTimestamp() { <span class="keywordflow">return</span> timestamp; } <span class="comment">// &lt; the higher the value, the longer the voice has been running</span></div><div class="line">     <span class="keywordtype">void</span> incrementTimestamp() { timestamp++; }    <span class="comment">// &lt; increment timestamp when a new note is triggered</span></div><div class="line">     <span class="keywordtype">void</span> clearTimestamp() { timestamp = 0; }      <span class="comment">// &lt; reset timestamp after voice is turned off</span></div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getMIDINoteNumber() { <span class="keywordflow">return</span> voiceMIDIEvent.midiData1; } <span class="comment">// &lt; note is data byte 1, velocity is byte 2</span></div><div class="line">     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getStealMIDINoteNumber() { <span class="keywordflow">return</span> voiceStealMIDIEvent.midiData1; } <span class="comment">// &lt; note is data byte 1, velocity is byte 2</span></div><div class="line">     <span class="keywordtype">bool</span> voiceIsStealing() { <span class="keywordflow">return</span> stealPending; } </div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">     <span class="comment">// --- standalone operation only </span></div><div class="line">     std::shared_ptr&lt;SynthVoiceParameters&gt; parameters = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- voice timestamp, for knowing the age of a voice</span></div><div class="line">     uint32_t timestamp = 0;                        </div><div class="line">     int32_t currentMIDINote = -1;              </div><div class="line"></div><div class="line">     <span class="comment">// --- note message state</span></div><div class="line">     voiceState voiceNoteState = voiceState::kNoteOffState; </div><div class="line"></div><div class="line">     <span class="comment">// --- per-voice stuff</span></div><div class="line">     <span class="keywordtype">bool</span> voiceIsActive = <span class="keyword">false</span>;    </div><div class="line">     midiEvent voiceMIDIEvent;  </div><div class="line"></div><div class="line">     <span class="comment">// --- for voice stealing</span></div><div class="line">     <span class="keywordtype">bool</span> stealPending = <span class="keyword">false</span>;     </div><div class="line">     midiEvent voiceStealMIDIEvent; </div><div class="line"></div><div class="line">};</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_voice_engine.html">Engine &amp; Voice Programming</a></li><li class="navelem"><a class="el" href="the_voice.html">SynthVoice Object</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
