<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Block Audio Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('the_block.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Block Audio Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SynthLab was designed from the ground up to follow an audio block processing paradigm that is relatively standard in the industry. The audio is rendered in blocks rather than one sample at a time. When you create the SynthEngine object, you initialize it with the maximum block size in frames (one sample per channel, e.g. 64 stereo frames occupy 64 sample intervals but produce two samples per interval). During the render operation, you also tell the engine how many samples of this maximum size are valid (require audio data) in case there are partial blocks to render. The SynthEngine will render audio samples in any amount up to the maximum, so partial blocks do not need special handling or buffering. If the user chooses a buffer size that is smaller than the engine's maximum, then these will be considered partial buffers, and will be rendered as normal; partial buffers are not optimal but are allowed. <br />
</p>
<p>The blocks of audio are usually short, 64 samples/channel or less, to maintain the tactile response of the instrument. During the render phase, the plugin framework prepares a <b>SynthProcessInfo structure</b> for the SynthEngine and passes in that structure during the render( ) function call.</p>
<p>The SynthProcessInfo structure:</p><ul>
<li>contains pointers to buffers for the engine to fill with freshly rendered audio data</li>
<li>includes a vector of midiEvent structures that encode the MIDI messages that occurred during that audio block time</li>
<li>contains fundamental DAW information about the current session; the BPM and time signature numerator/denominator</li>
</ul>
<p>In Figure 1, you can see how the framework sends blocks of empty buffers to the engine along with a chunk of MIDI messages that occurred during that block. The engine returns the output buffers filled with freshly rendered audio, which the framwork writes into its output buffers. The process repeats as the <b>render cycle</b>. Notice that this structure does <b>not</b> contain parameter information from the GUI. The GUI update part of the render cycle occurs just prior to the render( ) function call and covered in the previous section.</p>
<p><br />
 </p><div class="image">
<img src="engine_4.png" alt="engine_4.png"/>
</div>
<p> <br />
</p>
<p>Figure 1: the render cycle showing the relationship between the plugin framework and engine</p>
<p>In a likewise manner, the engine prepares a <b>single but separate SynthProcessInfo structure</b> to deliver to the SynthVoice objects that are "active" meaning that they are rendering audio for a note-event. Figure 2 shows the relationship between the engine, voices, and the SynthProcessInfo structures used during the function calls. The engine receives the SynthProcessInfo structure from the voice's render() function return, and accumulates it into the original SynthProcessInfo that the framework delivered. The voice does not use the SynthProcessInfo when rendering audio from it's SynthModule members. Instead, it uses the simpler AudioBuffer object.</p>
<p><br />
 </p><div class="image">
<img src="engine_5.png" alt="engine_5.png"/>
</div>
<p> <br />
</p>
<p>Figure 2: the engine uses a separate (green) SynthProcessInfo structure when calling the render() function on its active voices</p>
<p>The code below shows the SynthProcessInfo struct defintion. Take note of the following:</p><ul>
<li>it is derived from AudioBuffer, and inherits its input and output audio buffer arrays from this base class</li>
<li>it contains the MIDI event queue and helper functions to allow the framework to push fresh MIDI messages into it, prior to the call to the engine's render() function, and then clear out the messages once the render operation is complete.</li>
<li>the DAW data are just a set of simple members (BPM, time signature)</li>
<li>your framework should decode and send the absoluteBufferTime_Sec from the DAW via this structure's member, though the SynthLab example projects do not need or rely on this information</li>
<li>there is a preferred constructor that accepts the input/output channel counts and block size to setup and intialize its internal AudioBuffer arrays for operation</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- subclassed from AudioBuffer, inherits its audio I/O</span></div><div class="line"><span class="keyword">class </span>SynthProcessInfo : <span class="keyword">public</span> AudioBuffer</div><div class="line">{</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">          SynthProcessInfo(){}</div><div class="line">          SynthProcessInfo(uint32_t _numInputChannels, uint32_t _numOutputChannels, uint32_t _blockSize);</div><div class="line">          ~SynthProcessInfo() {}</div><div class="line"></div><div class="line">          <span class="comment">// --- MIDI events and functions</span></div><div class="line">          <span class="keywordtype">void</span> pushMidiEvent(midiEvent event);</div><div class="line">          <span class="keywordtype">void</span> clearMidiEvents();</div><div class="line">          uint32_t getMidiEventCount();</div><div class="line">          midiEvent* getMidiEvent(uint32_t index);</div><div class="line"></div><div class="line">          <span class="comment">// --- Aux information from the DAW </span></div><div class="line">          <span class="keywordtype">double</span> absoluteBufferTime_Sec = 0.0;     <span class="comment">// &lt; the time in seconds of the sample index at top of buffer</span></div><div class="line">          <span class="keywordtype">double</span> BPM = 0.0;                        <span class="comment">// &lt; beats per minute, aka &quot;tempo&quot;</span></div><div class="line">          <span class="keywordtype">double</span> timeSigNumerator = 0.0;           <span class="comment">// &lt; time signature numerator</span></div><div class="line">          uint32_t timeSigDenomintor = 0;          <span class="comment">// &lt; time signature denominator</span></div><div class="line"></div><div class="line">     <span class="keyword">protected</span>:</div><div class="line">          <span class="comment">// --- set of MIDI events for this audio processing block </span></div><div class="line">          std::vector&lt;midiEvent&gt; midiEventQueue;  <span class="comment">// &lt; queue </span></div><div class="line">};</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>It is important that you understand this structure because your plugin framework code will need to prepare that structure, load it with MIDI events, and pass it to the engine during render() calls in a sub-block processing loop within its own audio processing function in Figure 1.</p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_voice_engine.html">Engine &amp; Voice Programming</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
