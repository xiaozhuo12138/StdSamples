<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Minimal Standalone Synth</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('standalone_synth.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Minimal Standalone Synth </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>You can combine the stand-alone objects from the last sections into a single object that will render one complete note event. We'll put together a simple object that will generate a note event for the following block diagram using the objects we've already built - most of the code is already done for us. This will give you the most minimal impelementation possible and does not include global MIDI message decoding (for note and CC events) or other higher level operations. But you will be able to take this object and put it into your plugin framework, then send it MIDI events to render a note.</p>
<p><br />
 </p><div class="image">
<img src="minSynth_1.png" alt="minSynth_1.png"/>
</div>
<p> <br />
</p>
<p>You will build a container object here that will implement the five phases of synth operation and generate a C++ class you can integrate with your plugin framework today! It will also give you a lot to think about and will introduce the Voice and Engine objects in the next sections. For simplicity, let's lay out the object to mimic the wrap these 5 phases of operation and provide access to the output buffers of fresly rendered audio goodness. For this object, we will continue to keep a separate namespace and not use namespace SynthLab { } just yet.</p>
<p><b>Block Processing</b> This object will use block processing for all modules, unlike the standalone objects where we let the LFO and EG just render single frames of data. This will also demonstrate how the modulation values are granulized to cut down on calling the expensive update( ) function.</p>
<h2>The MinSynth Class </h2>
<p>Here is an ultra-simple C++ object that maintains the set of synth modules we need to create a single note event. I named the five functions after the same named functions on the SynthModules, though the arguments are not exactly the same. Instead, the arguments consist of whatever we need to perform the task for that function.</p><ul>
<li>notice the protected members are the synth modules</li>
<li>the render( ) function returns a const AudioBuffer pointer; it is the output of the DCA which is the last in the signal path of the block drawing.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinSynth</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="comment">// --- construct/destruct</span></div><div class="line">     MinSynth();</div><div class="line">     ~MinSynth() {}</div><div class="line"></div><div class="line">     <span class="comment">// --- operational phases</span></div><div class="line">     <span class="keywordtype">bool</span> reset(<span class="keywordtype">double</span> _sampleRate);</div><div class="line">     <span class="keywordtype">bool</span> update();</div><div class="line">     <span class="keyword">const</span> std::shared_ptr&lt;SynthLab::AudioBuffer&gt; render(uint32_t samplesToProcess = 1);</div><div class="line">     <span class="keywordtype">bool</span> doNoteOn(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent);</div><div class="line">     <span class="keywordtype">bool</span> doNoteOff(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">     <span class="comment">// --- synth components</span></div><div class="line">     std::unique_ptr&lt;SynthLab::SynthLFO&gt; lfo = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::EnvelopeGenerator&gt; ampEG = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::WTOscillator&gt; wtOsc = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::SynthFilter&gt; filter = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::DCA&gt; dca = <span class="keyword">nullptr</span>;</div><div class="line"><span class="comment">//</span></div><div class="line">};</div></div><!-- fragment --><p><b>constructor, reset() and update( )</b> <br />
 Now look at the constructor, reset() and update( ) functions.</p><ul>
<li>in the update( ) function, I am altering the parameters but NOT calling the update( ) function on the sub componens; this is because update( ) will be called at the top of the render cycle automatically</li>
<li>notice the update( ) function code for the filter: I am setting the value of MOD_KNOB_D to 1.0 because it is the Bipolar Modulation input intensity control (study the documentation!); if this value is 0.0, the LFO modulation will have no affecgt</li>
<li>ordinarily, the update( ) function would alter parameters on these objects as a result of GUI control changes, and you would place this code in your GUI handler for your plugin framework. Here, I am just hardcoding it for simplicity.</li>
</ul>
<div class="fragment"><div class="line">MinSynth::MinSynth()</div><div class="line">{</div><div class="line">     <span class="comment">// --- create the new modules here, all in standalone mode</span></div><div class="line">     <span class="comment">//    </span></div><div class="line">     <span class="comment">// --- LFO</span></div><div class="line">     lfo.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_synth_l_f_o.html">SynthLab::SynthLFO</a>(</div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* LFO parameters */</span></div><div class="line">          64));        <span class="comment">/* process individual samples (block size = 1)*/</span></div><div class="line"></div><div class="line">     <span class="comment">// --- EG</span></div><div class="line">     eg.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_envelope_generator.html">SynthLab::EnvelopeGenerator</a>(</div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* EG parameters */</span></div><div class="line">          64));        <span class="comment">/* process individual samples (block size = 1)*/</span></div><div class="line"></div><div class="line">     <span class="comment">// --- WTO</span></div><div class="line">     wtOsc.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_w_t_oscillator.html">SynthLab::WTOscillator</a>(</div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* WT parameters */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* wavetable database */</span></div><div class="line">          64));        <span class="comment">/* audio block size (one sample per channel)*/</span></div><div class="line"></div><div class="line">     <span class="comment">// --- FILTER</span></div><div class="line">     filter.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_synth_filter.html">SynthLab::SynthFilter</a>(</div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* filter parameters */</span></div><div class="line">          64));        <span class="comment">/* block size */</span></div><div class="line"></div><div class="line">     <span class="comment">// --- DCA</span></div><div class="line">     dca.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_d_c_a.html">SynthLab::DCA</a>( </div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* MIDI input data */</span></div><div class="line">          <span class="keyword">nullptr</span>,     <span class="comment">/* dca parameters */</span></div><div class="line">          64));        <span class="comment">/* block size */</span></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- forward calls to internal modules</span></div><div class="line"><span class="keywordtype">bool</span> MinSynth::reset(<span class="keywordtype">double</span> _sampleRate)</div><div class="line">{</div><div class="line">     <span class="comment">// --- reset components</span></div><div class="line">     lfo-&gt;reset(_sampleRate);</div><div class="line">     ampEG-&gt;reset(_sampleRate);</div><div class="line">     wtOsc-&gt;reset(_sampleRate);</div><div class="line">     filter-&gt;reset(_sampleRate);</div><div class="line">     dca-&gt;reset(_sampleRate);</div><div class="line"></div><div class="line">     <span class="comment">// --- update initialize</span></div><div class="line">     update();</div><div class="line">     </div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// done</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- set values from GUI controls, or programmatically from other objects</span></div><div class="line"><span class="comment">//     do not user for modulation, use the modulation inputs</span></div><div class="line"><span class="keywordtype">bool</span> MinSynth::update()</div><div class="line">{</div><div class="line">     <span class="comment">// --- reset components</span></div><div class="line">     <span class="comment">//     In each case: </span></div><div class="line">     <span class="comment">//      1. get parameter structure pointer</span></div><div class="line">     <span class="comment">//      2. alter values</span></div><div class="line">     <span class="comment">//      3. the call to update( ) is OPTIONAL and will be done anyway during render</span></div><div class="line">     std::shared_ptr&lt;SynthLab::LFOParameters&gt; lfoParameters = lfo-&gt;getParameters();</div><div class="line">     <span class="keywordflow">if</span> (lfoParameters) <span class="comment">// should never fail</span></div><div class="line">     {</div><div class="line">          <span class="comment">// --- NORMALLY these values will come from a GUI control</span></div><div class="line">          lfoParameters-&gt;waveformIndex = 8; <span class="comment">//&lt;- GUI control variable, hardcoded here</span></div><div class="line">          lfoParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_A] = 0.25;</div><div class="line"></div><div class="line">          <span class="comment">// --- call the update function (OPTIONAL, will be done anyway during render)</span></div><div class="line">          <span class="comment">// lfo-&gt;update();</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- EG</span></div><div class="line">     std::shared_ptr&lt;SynthLab::EGParameters&gt; egParameters = ampEG-&gt;getParameters();</div><div class="line">     <span class="keywordflow">if</span> (egParameters) <span class="comment">// should never fail</span></div><div class="line">     {</div><div class="line">          <span class="comment">// --- NORMALLY these values will come from a GUI control</span></div><div class="line">          egParameters-&gt;attackTime_mSec = 50.0;<span class="comment">//&lt;- GUI control variable, hardcoded here</span></div><div class="line">          egParameters-&gt;decayTime_mSec = 100.0;</div><div class="line">          egParameters-&gt;sustainLevel = 0.707;</div><div class="line">          egParameters-&gt;releaseTime_mSec = 1000.0;</div><div class="line"></div><div class="line">          <span class="comment">// --- call the update function (OPTIONAL, will be done anyway during render)</span></div><div class="line">          <span class="comment">// ampEG-&gt;update();</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- OSC</span></div><div class="line">     std::shared_ptr&lt;SynthLab::WTOscParameters&gt; wtoParameters = wtOsc-&gt;getParameters();</div><div class="line">     <span class="keywordflow">if</span> (wtoParameters) <span class="comment">// should never fail</span></div><div class="line">     {</div><div class="line">          <span class="comment">// --- NORMALLY these values will come from a GUI control</span></div><div class="line">          wtoParameters-&gt;waveIndex = 1; <span class="comment">// FourierWTCore parabola</span></div><div class="line">          wtoParameters-&gt;outputAmplitude_dB = -3.0;</div><div class="line"></div><div class="line">          <span class="comment">// --- call the update function (OPTIONAL, will be done anyway during render)</span></div><div class="line">          <span class="comment">// wtOsc-&gt;update();</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="comment">// --- filter</span></div><div class="line">     std::shared_ptr&lt;SynthLab::FilterParameters&gt; filterParameters = filter-&gt;getParameters();</div><div class="line">     <span class="keywordflow">if</span> (filterParameters) <span class="comment">// should never fail</span></div><div class="line">     {</div><div class="line">          <span class="comment">// --- NORMALLY these values will come from a GUI control</span></div><div class="line">          filterParameters-&gt;filterIndex = 4; <span class="comment">// SVF LP</span></div><div class="line">          filterParameters-&gt;fc = 880.0;</div><div class="line">          filterParameters-&gt;Q = 5;</div><div class="line">          filterParameters-&gt;filterOutputGain_dB = -2.0;</div><div class="line">          filterParameters-&gt;modKnobValue[SynthLab::MOD_KNOB_D] = 1.0; <span class="comment">// max intensity</span></div><div class="line"></div><div class="line">          <span class="comment">// --- call the update function (OPTIONAL, will be done anyway during render)</span></div><div class="line">          <span class="comment">// filter-&gt;update();</span></div><div class="line">     }</div><div class="line"></div><div class="line">     std::shared_ptr&lt;SynthLab::DCAParameters&gt; dcaParameters = dca-&gt;getParameters();</div><div class="line">     <span class="keywordflow">if</span> (dcaParameters) <span class="comment">// should never fail</span></div><div class="line">     {</div><div class="line">          <span class="comment">// --- NORMALLY these values will come from a GUI control</span></div><div class="line">          dcaParameters-&gt;gainValue_dB = +3.0;</div><div class="line">          dcaParameters-&gt;panValue = 0.25; <span class="comment">// 1/4 to the right, 3/4 to the left</span></div><div class="line"></div><div class="line">          <span class="comment">// --- call the update function (OPTIONAL, will be done anyway during render)</span></div><div class="line">          <span class="comment">// dca-&gt;update();</span></div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// done</span></div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>render( )</b> <br />
 In this most important function, we need to render the modulation values from the LFO and EG first, then apply them to the filter and oscillator's modulation inputs. You will need to study the documentation and/or the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> to understand better how this works, but all of the modulation array slot constants can be found in <a class="el" href="synthconstants_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">synthconstants.h</a> and you can use the sample synth code for more references. <br />
</p>
<p>Notice how I render and apply the modulation values in sequence.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::shared_ptr&lt;SynthLab::AudioBuffer&gt; MinSynth::render(uint32_t samplesToProcess)</div><div class="line">{</div><div class="line">     <span class="comment">// --- render LFO output, get modulation output</span></div><div class="line">     lfo-&gt;render(samplesToProcess);</div><div class="line">     <span class="keywordtype">double</span> lfoNormOut = lfo-&gt;getModulationOutput()-&gt;getModValue(SynthLab::kLFONormalOutput);</div><div class="line"></div><div class="line">     <span class="comment">// --- MODULATE: apply lfo output to the modulation inputs of the oscillator and filter</span></div><div class="line">     wtOsc-&gt;getModulationInput()-&gt;setModValue(SynthLab::kBipolarMod, lfoNormOut);</div><div class="line">     filter-&gt;getModulationInput()-&gt;setModValue(SynthLab::kBipolarMod, lfoNormOut);</div><div class="line"></div><div class="line">     <span class="comment">// --- render EG output, get modulation output</span></div><div class="line">     ampEG-&gt;render(samplesToProcess);</div><div class="line">     <span class="keywordtype">double</span> egNormOut = ampEG-&gt;getModulationOutput()-&gt;getModValue(SynthLab::kEGNormalOutput);</div><div class="line"></div><div class="line">     <span class="comment">// --- MODULATE: apply EG output to the kEGMod modulation input of the dca</span></div><div class="line">     dca-&gt;getModulationInput()-&gt;setModValue(SynthLab::kEGMod, egNormOut);</div><div class="line"></div><div class="line">     <span class="comment">// --- render oscillator</span></div><div class="line">     wtOsc-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from OSC output to filter input</span></div><div class="line">     <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a>(wtOsc-&gt;getAudioBuffers(), </div><div class="line">          filter-&gt;getAudioBuffers(), </div><div class="line">          SynthLab::STEREO_TO_STEREO, 64);</div><div class="line"></div><div class="line">     <span class="comment">// --- render filter</span></div><div class="line">     filter-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from fikter output to DCA input</span></div><div class="line">     <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a>(filter-&gt;getAudioBuffers(), </div><div class="line">          dca-&gt;getAudioBuffers(), </div><div class="line">          SynthLab::STEREO_TO_STEREO, 64);</div><div class="line"></div><div class="line">     <span class="comment">// --- render DCA</span></div><div class="line">     dca-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- AT THIS POINT, the rendered synth audio is sitting in the DCA&#39;s AudioBuffer output array</span></div><div class="line">     <span class="keywordflow">return</span> dca-&gt;getAudioBuffers();</div><div class="line">     </div><div class="line">     <span class="comment">//</span></div><div class="line">}</div></div><!-- fragment --><p><b>noteOn( ) and noteOff( )</b> <br />
 These two functions are trivial as they simply forward the MIDI event data to the underlying components.</p>
<div class="fragment"><div class="line"><span class="comment">// --- just send the note event to the synth modules</span></div><div class="line"><span class="keywordtype">bool</span> MinSynth::doNoteOn(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent)</div><div class="line">{</div><div class="line">     lfo-&gt;doNoteOn(noteEvent);</div><div class="line">     ampEG-&gt;doNoteOn(noteEvent);</div><div class="line">     wtOsc-&gt;doNoteOn(noteEvent);</div><div class="line">     filter-&gt;doNoteOn(noteEvent);</div><div class="line">     dca-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// done</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- just send the note event to the synth modules</span></div><div class="line"><span class="keywordtype">bool</span> MinSynth::doNoteOff(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent)</div><div class="line">{</div><div class="line">     lfo-&gt;doNoteOff(noteEvent);</div><div class="line">     ampEG-&gt;doNoteOff(noteEvent);</div><div class="line">     wtOsc-&gt;doNoteOff(noteEvent);</div><div class="line">     filter-&gt;doNoteOff(noteEvent);</div><div class="line">     dca-&gt;doNoteOff(noteEvent);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// done</span></div><div class="line">}</div></div><!-- fragment --><p><b>Using MinSynth</b> <br />
 Using the object makes your plugin framework code very compact. All you need to do is follow the same steps as before, but now with a single object rather than the collection.</p>
<div class="fragment"><div class="line"><span class="comment">// --- static instance, named miniSynth</span></div><div class="line">MinSynth miniSynth;</div><div class="line"></div><div class="line"><span class="comment">// --- initialize</span></div><div class="line">miniSynth.reset(44100.0); <span class="comment">//&lt;- get fs from your plugin framework</span></div><div class="line"></div><div class="line"><span class="comment">// --- call the update function once to inialize</span></div><div class="line">miniSynth.update();</div></div><!-- fragment --><p>Use the note-on and note-off handlers as normal, from your plugin framework MIDI handler function.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a> midiEvent;</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a> = 60;   <span class="comment">// &lt;-- get from your MIDI handler</span></div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a7c1a0e203aa66105e2f69d3f2850881d">midiPitch</a> = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">SynthLab::midiNoteNumberToOscFrequency</a>(midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a>);</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a93dce735febfe26bc91a4b17922adec9">midiNoteVelocity</a> = 127;<span class="comment">// &lt;-- get from your MIDI handler</span></div><div class="line"></div><div class="line"><span class="comment">// --- do the note on event</span></div><div class="line">miniSynth.doNoteOn(midiEvent);</div><div class="line"></div><div class="line"><span class="comment">// ... or at note off time:</span></div><div class="line">miniSynth.doNoteOff(midiEvent);</div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>Next, update the components each time your plugin GUI handler is called. Transfer your GUI variables into the objects, but do NOT call update( ) as it will be called automatically, just prior to the render( ) function call. Finally, call the render function. These operations are shown together here. The object returns a shared pointer to the audio output data so send it to your plugin framework output before ending the function.</p>
<div class="fragment"><div class="line"><span class="comment">// --- do fresh GUI update for this block of data</span></div><div class="line">update( );</div><div class="line"></div><div class="line"><span class="comment">// --- render a block of 64 samples</span></div><div class="line"><span class="keyword">const</span> std::shared_ptr&lt;SynthLab::AudioBuffer&gt; synthBuffer = miniSynth.render(64);</div><div class="line"></div><div class="line"><span class="comment">// --- iterate through the array, or memcpy( ) it to your plugin framework output</span></div><div class="line"><span class="keywordtype">float</span>* leftOutBuffer = synthBuffer-&gt;getOutputBuffer(SynthLab::LEFT_CHANNEL);</div><div class="line"><span class="keywordtype">float</span>* rightOutBuffer = synthBuffer-&gt;getOutputBuffer(SynthLab::RIGHT_CHANNEL);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (uint32_t i = 0; i &lt; 64; i++)</div><div class="line">{</div><div class="line">     <span class="keywordtype">float</span> leftSample = leftOutBuffer[i];</div><div class="line">     <span class="keywordtype">float</span> rightSample = rightOutBuffer[i];</div><div class="line">     </div><div class="line">     <span class="comment">// --- send the two outputs to the real-world here...</span></div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Congrats! You now have a functing synth object that can render a note from a MIDI event. In the next section, we will replace the modulation code with the Modulation Matrix instead!</b></p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="standalone.html">Standalone Programming</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
