<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: SynthVoice Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('voice_min_synth.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SynthVoice Example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the <a class="el" href="standalone_synth.html">Minimal Standalone Synth</a> section, you saw how to create the MinSynth C++ object that owns and maintains a small set of SynthModule objects, that it arranges and manages to render audio into output buffers. Please review that section prior to going through this exercise, where I convert the MinSynth object into a SynthVoice object and leverage off of the built-in code. Here is the class definition for the MinSynth object and the block diagram of the voice (patch) it implements.</p>
<p><br />
 </p><div class="image">
<img src="minSynth_1.png" alt="minSynth_1.png"/>
</div>
<p> <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- Minimal Synth C++ object</span></div><div class="line"><span class="keyword">class </span>MinSynth</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// --- construct/destruct</span></div><div class="line">    MinSynth();</div><div class="line">    ~MinSynth() {}</div><div class="line"></div><div class="line">    <span class="comment">// --- operational phases</span></div><div class="line">    <span class="keywordtype">bool</span> reset(<span class="keywordtype">double</span> _sampleRate);</div><div class="line">    <span class="keywordtype">bool</span> update();</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;SynthLab::AudioBuffer&gt; render(uint32_t samplesToProcess = 1);</div><div class="line">    <span class="keywordtype">bool</span> doNoteOn(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent);</div><div class="line">    <span class="keywordtype">bool</span> doNoteOff(<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a>&amp; noteEvent);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// --- synth components</span></div><div class="line">    std::unique_ptr&lt;SynthLab::SynthLFO&gt; lfo = <span class="keyword">nullptr</span>;</div><div class="line">    std::unique_ptr&lt;SynthLab::EnvelopeGenerator&gt; ampEG = <span class="keyword">nullptr</span>;</div><div class="line">    std::unique_ptr&lt;SynthLab::WTOscillator&gt; wtOsc = <span class="keyword">nullptr</span>;</div><div class="line">    std::unique_ptr&lt;SynthLab::SynthFilter&gt; filter = <span class="keyword">nullptr</span>;</div><div class="line">    std::unique_ptr&lt;SynthLab::DCA&gt; dca = <span class="keyword">nullptr</span>;</div><div class="line">    std::unique_ptr&lt;SynthLab::ModMatrix&gt; modMatrix = <span class="keyword">nullptr</span>;</div><div class="line">};</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p>We are going to use the same set of SynthModules in the newly revised SynthVoice version with the added benefit of the template code and parameter sharing features.</p>
<h2>Add the Voice's SynthModule Members </h2>
<p>First, modify the synthvoice.h template file by adding the SynthModule object declarations as protected members. I am using the std::shared_ptr to manage my dynamically allocated objects but you may certainly use other methods.</p>
<div class="fragment"><div class="line"><span class="comment">// --- module files</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="lfo_8h.html">lfo.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="envelopegenerator_8h.html">envelopegenerator.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="wtoscillator_8h.html">wtoscillator.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="synthfilter_8h.html">synthfilter.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;oscillator.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="filtermodule_8h.html">filtermodule.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dca_8h.html">dca.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="modmatrix_8h.html">modmatrix.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// --- now in the protected section of the template code:</span></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">     <span class="comment">// --- standalone operation only </span></div><div class="line">     std::shared_ptr&lt;SynthVoiceParameters&gt; parameters = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- MinSynth members</span></div><div class="line">     std::unique_ptr&lt;SynthLab::SynthLFO&gt; lfo = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::EnvelopeGenerator&gt; ampEG = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::WTOscillator&gt; wtOsc = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::SynthFilter&gt; filter = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::DCA&gt; dca = <span class="keyword">nullptr</span>;</div><div class="line">     std::unique_ptr&lt;SynthLab::ModMatrix&gt; modMatrix = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- local storage</span></div><div class="line">     <span class="keywordtype">double</span> sampleRate = 0.0;</div><div class="line">     uint32_t blockSize = 64;</div><div class="line"></div><div class="line">     <span class="comment">// --- interface pointer</span></div><div class="line">     std::shared_ptr&lt;MidiInputData&gt; midiInputData = <span class="keyword">nullptr</span>;            </div><div class="line"></div><div class="line">     <span class="comment">// --- REST OF DECLARATION IS IDENTICAL TO TEMPLATE</span></div><div class="line">     <span class="comment">// ...</span></div></div><!-- fragment --><p>Next, add shared parameter strucures to the SynthVoiceParameters struct in the same file. Add one new shared pointer for each object's parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// --- modify the parameters</span></div><div class="line"><span class="keyword">struct </span>SynthVoiceParameters</div><div class="line">{</div><div class="line">     SynthVoiceParameters() {}</div><div class="line"></div><div class="line">     <span class="comment">// --- shared parameter structs for each module</span></div><div class="line">     <span class="comment">//</span></div><div class="line">     <span class="comment">// --- oscillator</span></div><div class="line">     std::shared_ptr&lt;WTOscParameters&gt; wtOscParameters = std::make_shared&lt;WTOscParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- LFOs</span></div><div class="line">     std::shared_ptr&lt;LFOParameters&gt; lfoParameters = std::make_shared&lt;LFOParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- EGs</span></div><div class="line">     std::shared_ptr&lt;EGParameters&gt; ampEGParameters = std::make_shared&lt;EGParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- filters</span></div><div class="line">     std::shared_ptr&lt;FilterParameters&gt; filterParameters = std::make_shared&lt;FilterParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- DCA</span></div><div class="line">     std::shared_ptr&lt;DCAParameters&gt; dcaParameters = std::make_shared&lt;DCAParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- ModMatrix</span></div><div class="line">     std::shared_ptr&lt;ModMatrixParameters&gt; modMatrixParameters = std::make_shared&lt;ModMatrixParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- REST OF STRUCT IS SAME AS TEMPLATE --//</span></div><div class="line">     </div><div class="line">     <span class="comment">// --- synth mode; engine has same variable</span></div><div class="line">     uint32_t synthModeIndex = <a class="code" href="group___constants-_enums.html#gafe6b97a9f03775e21060ed411465d1a6">enumToInt</a>(SynthMode::kMono);</div><div class="line"></div><div class="line">     <span class="comment">// --- synth mode; engine has same variable</span></div><div class="line">     uint32_t filterModeIndex = <a class="code" href="group___constants-_enums.html#gafe6b97a9f03775e21060ed411465d1a6">enumToInt</a>(FilterMode::kSeries);</div><div class="line"></div><div class="line">     <span class="comment">// --- portamento (glide)</span></div><div class="line">     <span class="keywordtype">bool</span> enablePortamento = <span class="keyword">false</span>;</div><div class="line">     </div><div class="line">     <span class="comment">// --- glide time</span></div><div class="line">     <span class="keywordtype">double</span> glideTime_mSec = 0.0;</div><div class="line"></div><div class="line">     <span class="comment">// --- legato mode</span></div><div class="line">     <span class="keywordtype">bool</span> legatoMode = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- freerun</span></div><div class="line">     <span class="keywordtype">bool</span> freeRunOscMode = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">     <span class="comment">// --- unison Detune - each voice will be detuned differently</span></div><div class="line">     <span class="keywordtype">double</span> unisonDetuneCents = 0.0;</div><div class="line">     <span class="keywordtype">double</span> unisonStartPhase = 0.0;</div><div class="line">     <span class="keywordtype">double</span> unisonPan = 0.0;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Construct the SynthModule Members </h2>
<p>In the SynthVoice constructor, you create the SynthModules. Unlike the standalone versions, these will reecive non-null shared pointers to shared resources. Some of these resources came from the engine, and arrived into the voice object's constructor. The shared parameter structures are part of the voice's SynthVoiceParameter structure. So you can see how the shared resources are divided between the engine (MIDI input, wavetable, and PCM sample data) and the voice (all module parameter structures). Here is the first part of the constructor where the modules are instantiated with smart pointers.</p>
<div class="fragment"><div class="line"><span class="comment">// --- voice constructor</span></div><div class="line">SynthVoice::SynthVoice(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">                       std::shared_ptr&lt;MidiOutputData&gt; _midiOutputData,</div><div class="line">                       std::shared_ptr&lt;SynthVoiceParameters&gt; _parameters,</div><div class="line">                       std::shared_ptr&lt;WavetableDatabase&gt; _wavetableDatabase,</div><div class="line">                       std::shared_ptr&lt;PCMSampleDatabase&gt; _sampleDatabase,</div><div class="line">                       uint32_t _blockSize)</div><div class="line">     : midiInputData(_midiInputData)        <span class="comment">//&lt;- set our midi dat interface value</span></div><div class="line">     , midiOutputData(_midiOutputData)</div><div class="line">     , parameters(_parameters)  <span class="comment">//&lt;- set our parameters</span></div><div class="line">     , wavetableDatabase(_wavetableDatabase)</div><div class="line">     , sampleDatabase(_sampleDatabase)</div><div class="line">     , blockSize(_blockSize)</div><div class="line">{</div><div class="line">     <span class="comment">// for standalone</span></div><div class="line">     <span class="keywordflow">if</span> (!midiInputData)</div><div class="line">          midiInputData.reset(<span class="keyword">new</span> (MidiInputData));</div><div class="line">     <span class="keywordflow">if</span> (!midiOutputData)</div><div class="line">          midiOutputData.reset(<span class="keyword">new</span> (MidiOutputData));</div><div class="line"></div><div class="line">     <span class="comment">// --- this happens in stand-alone mode; does not happen otherwise;</span></div><div class="line">     <span class="comment">//     the first initialized SynthLab component creates its own parameters</span></div><div class="line">     <span class="keywordflow">if</span> (!parameters)</div><div class="line">          parameters = std::make_shared&lt;SynthVoiceParameters&gt;();</div><div class="line"></div><div class="line">     <span class="comment">// --- NOTE: in standalone mode, the modules will create the wavetable and PCM databases</span></div><div class="line">     <span class="comment">//           locally, so they do not need to be checked here.</span></div><div class="line"></div><div class="line">     <span class="comment">// --- LFOs</span></div><div class="line">     lfo.reset(<span class="keyword">new</span> SynthLFO(midiInputData, parameters-&gt;lfoParameters, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- EGs</span></div><div class="line">     ampEG.reset(<span class="keyword">new</span> EnvelopeGenerator(midiInputData, parameters-&gt;ampEGParameters, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- wt oscillator</span></div><div class="line">     wtOsc.reset(<span class="keyword">new</span> WTOscillator(midiInputData, parameters-&gt;wtOscParameters, wavetableDatabase, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- filters</span></div><div class="line">     filter.reset(<span class="keyword">new</span> SynthFilter(midiInputData, parameters-&gt;filterParameters, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- DCA</span></div><div class="line">     dca.reset(<span class="keyword">new</span> DCA(midiInputData, parameters-&gt;dcaParameters, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- mod matrix</span></div><div class="line">     modMatrix.reset(<span class="keyword">new</span> ModMatrix(parameters-&gt;modMatrixParameters));</div><div class="line"></div><div class="line">     <span class="comment">// --- THIS IS IN THE TEMPLATE CODE...</span></div><div class="line">     <span class="comment">// --- create our audio buffers</span></div><div class="line">     mixBuffers.reset(<span class="keyword">new</span> SynthProcessInfo(<a class="code" href="group___constants-_enums.html#ga5aa686803c275f895c0f456702b01488">NO_CHANNELS</a>, STEREO_CHANNELS, blockSize));</div><div class="line">     <span class="comment">//</span></div></div><!-- fragment --><p>Now that the objects have been created with shared resources, we can program the modulation matrix. This code is lifted directly from the MinSynth section in <a class="el" href="standalone_synth.html">Minimal Standalone Synth</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- mod matrix can be reconfigured on the fly</span></div><div class="line"><span class="comment">//     </span></div><div class="line"><span class="comment">// --- clear out</span></div><div class="line">modMatrix-&gt;clearModMatrixArrays();</div><div class="line"></div><div class="line"><span class="comment">// --- setup possible sources and destinations; can also be done on the fly</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// --- add the sources</span></div><div class="line">modMatrix-&gt;addModSource(SynthLab::kSourceLFO1_Norm, lfo-&gt;getModulationOutput()-&gt;getModArrayPtr(SynthLab::kLFONormalOutput));</div><div class="line">modMatrix-&gt;addModSource(SynthLab::kSourceAmpEG_Norm, ampEG-&gt;getModulationOutput()-&gt;getModArrayPtr(SynthLab::kEGNormalOutput));</div><div class="line"></div><div class="line"><span class="comment">// --- add the destinations</span></div><div class="line">modMatrix-&gt;addModDestination(SynthLab::kDestOsc1_fo, wtOsc-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kBipolarMod));</div><div class="line">modMatrix-&gt;addModDestination(SynthLab::kDestFilter1_fc_Bipolar, filter-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kBipolarMod));</div><div class="line">modMatrix-&gt;addModDestination(SynthLab::kDestDCA_EGMod, dca-&gt;getModulationInput()-&gt;getModArrayPtr(SynthLab::kEGMod));</div><div class="line"></div><div class="line"><span class="comment">// --- hardwire the routings for now; the default hardwired intenstity is 1.0</span></div><div class="line">modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceLFO1_Norm, SynthLab::kDestOsc1_fo);</div><div class="line">modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceLFO1_Norm, SynthLab::kDestFilter1_fc_Bipolar);</div><div class="line">modMatrix-&gt;getParameters()-&gt;setMM_HardwiredRouting(SynthLab::kSourceAmpEG_Norm, SynthLab::kDestDCA_EGMod);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>Descend the Operational Phase Functions </h2>
<p>Next, move through the operational phase functions, adding code as needed. Many of these will simply call the same named function on one or all of the member modules.</p>
<p><b>reset() and initialize()</b> <br />
</p><ul>
<li>the reset function forwards the reset() calls to the modules and sets some member variables</li>
<li>the initialization function only needs to be called on oscillators in SynthLab; that is done here even though the SynthLab wavetable oscillators do not need the path; yours might need this for parsing wavetable data files or other initialization chores</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- reset modules</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::reset(<span class="keywordtype">double</span> _sampleRate)</div><div class="line">{</div><div class="line">     sampleRate = _sampleRate;</div><div class="line">     currentMIDINote = -1;</div><div class="line"></div><div class="line">     <span class="comment">// --- reset modules</span></div><div class="line">     lfo-&gt;reset(_sampleRate);</div><div class="line">     ampEG-&gt;reset(_sampleRate);</div><div class="line">     wtOsc-&gt;reset(_sampleRate);</div><div class="line">     filter-&gt;reset(_sampleRate);</div><div class="line">     dca-&gt;reset(_sampleRate);</div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- intialize oscillator with path</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::initialize(<span class="keyword">const</span> <span class="keywordtype">char</span>* dllPath)</div><div class="line">{</div><div class="line">     <span class="comment">// --- initialize all sub components that need the DLL path</span></div><div class="line">     wtOsc-&gt;initialize(dllPath);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>update()</b> <br />
 The voice only needs to set the unison mode detuning and phase start variables on the oscillators. This is done for the sole wavetable oscillator only.</p>
<div class="fragment"><div class="line"><span class="comment">// --- updater </span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::update()</div><div class="line">{</div><div class="line">     <span class="comment">// --- do updates to sub-components </span></div><div class="line">     <span class="comment">//     NOTE: this is NOT for GUI control updates for normal synth operation</span></div><div class="line">     <span class="comment">//</span></div><div class="line">     <span class="comment">// ---- sets unison mode detuning and phase from GUI controls (optional)</span></div><div class="line">     wtOsc-&gt;setUnisonMode(parameters-&gt;unisonDetuneCents, parameters-&gt;unisonStartPhase);</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>render()</b> <br />
 The render() function follows the same logic and code as the MinSynth object. The only difference here is the bit of code at the end, that checks to see if the amp EG has expired, so that the voice state variable may be set.</p>
<div class="fragment"><div class="line"><span class="comment">// --- render the modules</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::render(SynthProcessInfo&amp; synthProcessInfo)</div><div class="line">{</div><div class="line">     uint32_t samplesToProcess = synthProcessInfo.getSamplesInBlock();</div><div class="line"></div><div class="line">     <span class="comment">// --- clear for accumulation</span></div><div class="line">     mixBuffers-&gt;flushBuffers();</div><div class="line"></div><div class="line">     <span class="comment">// --- render LFO outputt</span></div><div class="line">     lfo-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- render EG output</span></div><div class="line">     ampEG-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- do the modulation routings</span></div><div class="line">     modMatrix-&gt;runModMatrix();</div><div class="line"></div><div class="line">     <span class="comment">// --- render oscillator</span></div><div class="line">     wtOsc-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from OSC output to filter input</span></div><div class="line">     <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">copyOutputToInput</a>(wtOsc-&gt;getAudioBuffers(),   <span class="comment">/* from */</span></div><div class="line">                       filter-&gt;getAudioBuffers(),  <span class="comment">/* to */</span></div><div class="line">                       SynthLab::STEREO_TO_STEREO, <span class="comment">/* stereo */</span></div><div class="line">                       blockSize);                 <span class="comment">/* block length */</span></div><div class="line"></div><div class="line">     <span class="comment">// --- render filter</span></div><div class="line">     filter-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- transfer information from fikter output to DCA input</span></div><div class="line">    <a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">copyOutputToInput</a>(filter-&gt;getAudioBuffers(),    <span class="comment">/* from */</span></div><div class="line">                      dca-&gt;getAudioBuffers(),       <span class="comment">/* to */</span></div><div class="line">                      SynthLab::STEREO_TO_STEREO,   <span class="comment">/* stereo */</span></div><div class="line">                      blockSize);                   <span class="comment">/* block length */</span></div><div class="line"></div><div class="line">     <span class="comment">// --- render DCA</span></div><div class="line">     dca-&gt;render(samplesToProcess);</div><div class="line"></div><div class="line">     <span class="comment">// --- to mains</span></div><div class="line">     <a class="code" href="group___synth_functions.html#gaecaba409aa2dd92074ee74c2ac4e0870">copyOutputToOutput</a>(dca-&gt;getAudioBuffers(),     <span class="comment">/* from */</span></div><div class="line">                        synthProcessInfo,           <span class="comment">/* to */</span></div><div class="line">                        STEREO_TO_STEREO,           <span class="comment">/* stereo */</span></div><div class="line">                        samplesToProcess);          <span class="comment">/* block length */</span></div><div class="line"></div><div class="line">     <span class="comment">// --- check for note off condition</span></div><div class="line">     <span class="keywordflow">if</span> (voiceIsActive)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- has ampEG expired yet?</span></div><div class="line">          <span class="keywordflow">if</span> (ampEG-&gt;getState() == <a class="code" href="group___constants-_enums.html#gafe6b97a9f03775e21060ed411465d1a6">enumToInt</a>(EGState::kOff))</div><div class="line">          {             </div><div class="line">               voiceIsActive = <span class="keyword">false</span>;</div><div class="line">          }</div><div class="line">     }</div><div class="line">     <span class="comment">// done</span></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// </span></div></div><!-- fragment --><p><b>doNoteOn()</b> <br />
 The note-on handler mainly passes the message down to the modules. But it is also where you will start the glide modulator if neeeded.Each SynthModule includes a GlideModulator object, documented in the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a>, to perform portamento.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note on handler</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::doNoteOn(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="comment">// --- calculate MIDI -&gt; pitch value</span></div><div class="line">     <span class="keywordtype">double</span> midiPitch = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">midiNoteNumberToOscFrequency</a>(event.midiData1);</div><div class="line">     int32_t lastMIDINote = currentMIDINote;</div><div class="line">     currentMIDINote = (int32_t)event.midiData1;</div><div class="line"></div><div class="line">     MIDINoteEvent noteEvent(midiPitch, event.midiData1, event.midiData2);</div><div class="line">     <span class="comment">// --- TEMPLATE CODE END</span></div><div class="line"></div><div class="line">     <span class="comment">// --- needed forLFO  modes</span></div><div class="line">     lfo-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- EG</span></div><div class="line">     ampEG-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- create glide info structure out of notes and times</span></div><div class="line">     GlideInfo glideInfo(lastMIDINote, currentMIDINote, parameters-&gt;glideTime_mSec, sampleRate);</div><div class="line"></div><div class="line">     <span class="comment">// --- set glide mod</span></div><div class="line">     wtOsc-&gt;startGlideModulation(glideInfo);</div><div class="line">     wtOsc-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- filter needs note on for key track</span></div><div class="line">     filter-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- DCA</span></div><div class="line">     dca-&gt;doNoteOn(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- TEMPLATE CODE CONTINUED</span></div><div class="line">     <span class="comment">// --- set the flag</span></div><div class="line">     voiceIsActive = <span class="keyword">true</span>; <span class="comment">// we are ON</span></div><div class="line">     voiceNoteState = voiceState::kNoteOnState;</div><div class="line"></div><div class="line">     <span class="comment">// --- this saves the midi note number and velocity so that we can identify our own note</span></div><div class="line">     voiceMIDIEvent = event;</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// --- </span></div></div><!-- fragment --><p><b>doNoteOff()</b> <br />
 The note-on handler mainly passes the message down to the modules. This also sets the voice state to kNoteOffState but that does not mean the note event is finished, which is only triggered by the expiration of the amp EG object.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note off</span></div><div class="line"><span class="keywordtype">bool</span> SynthVoice::doNoteOff(midiEvent&amp; event)</div><div class="line">{</div><div class="line">     <span class="comment">// --- lookup MIDI -&gt; pitch value</span></div><div class="line">     <span class="keywordtype">double</span> midiPitch = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">midiNoteNumberToOscFrequency</a>(event.midiData1);</div><div class="line"></div><div class="line">     MIDINoteEvent noteEvent(midiPitch, event.midiData1, event.midiData2);</div><div class="line"></div><div class="line">     <span class="comment">// --- components</span></div><div class="line">     lfo-&gt;doNoteOff(noteEvent);</div><div class="line">     ampEG-&gt;doNoteOff(noteEvent);</div><div class="line">     wtOsc-&gt;doNoteOff(noteEvent);</div><div class="line">     filter-&gt;doNoteOff(noteEvent);</div><div class="line">     dca-&gt;doNoteOff(noteEvent);</div><div class="line"></div><div class="line">     <span class="comment">// --- set our current state; the ampEG will determine the final state</span></div><div class="line">     voiceNoteState = voiceState::kNoteOffState;</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p>That's all there is to coding the SynthVoice object for note rendering operation. You will see that the example voice objects really only differ by including multiple modules: 2 LFOs, 3 EGs, 2 filters, 4 oscillators, etc... but the code follows the same pattern.</p>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_voice_engine.html">Engine &amp; Voice Programming</a></li><li class="navelem"><a class="el" href="the_voice.html">SynthVoice Object</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
