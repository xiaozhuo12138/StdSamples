<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SynthLab SDK: Create a Filter Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SynthLab SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('create_filter.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Create a Filter Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Copy the <b><a class="el" href="synthmodule__nocores_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">synthmodule_nocores.h</a></b> and <b><a class="el" href="synthmodule__nocores_8cpp.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">synthmodule_nocores.cpp</a></b> files into your project. You will probably want to rename them to something sensible. Open them in your compiler or a text editor and change the occurrances of <b>SynthModuleNoCores</b> to <b>FilterModule</b> or anything else that makes sense. Here I am calling the object <b>FilterModule</b>.</p>
<h2>FilterModule Plan </h2>
<p>The <b>synthbase</b> code contains a built-in object called <b>BQAudioFilter</b> that implements an augmented biquad structure that is described and used in detail in my FX book. We will use this object here to implement two filters that are in neither the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a> nor the sample project code: Vicanek's Analog Matched 2nd order lowpass and 2nd order bandpass filters with the "loose fit" algorithms, giving us two filter types that will become the module strings. We will use the parameter structure to test the object and will implement one mod knob control for filter keytrack modulation, that is explained in the next section. <br />
</p>
<p>Filter Module Specifications:</p><ul>
<li>module strings: are the two filter types "VicLPF2" and "VicBPF2"</li>
<li>mod knobs: MOD_KNOB_A is "Key Track"</li>
</ul>
<p>Figure 1 shows the frequency responses of the Vicanek loose and tight fit filters compared to the bilinear transform versions.</p>
<p><br />
 </p><div class="image">
<img src="vicanek.png" alt="vicanek.png"/>
</div>
<p> <br />
</p>
<p>Figure 1: Vicanek's frequency responses for LPF (left) and BPF (right) from "Designing Audio Effects Plugins in C++ 2nd Ed." by Will Pirkle</p>
<h2>BQAudioFilter </h2>
<p>The BQAudioFilter object is a thin wrapper for the augmented biquad structure from my FX book. It accepts a structure of coefficients and then runs the augmented biquad routine using the Transposed Canonical form. This object does not need to know about the sample rate or type of filter, it only runs the biquad routine. We will need two of these objects, one for each channel for stereo operation.</p>
<div class="fragment"><div class="line"><span class="comment">// --- thin biquad wrapper</span></div><div class="line"><span class="keyword">class </span>BQAudioFilter</div><div class="line">{</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">     BQAudioFilter(<span class="keywordtype">void</span>) {}     <span class="comment">/* C-TOR */</span></div><div class="line">     ~BQAudioFilter(<span class="keywordtype">void</span>) {}    <span class="comment">/* D-TOR */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">     <span class="comment">// --- reset the object </span></div><div class="line">     <span class="keywordtype">void</span> reset();</div><div class="line"></div><div class="line">     <span class="comment">// --- flush state variables </span></div><div class="line">     <span class="keywordtype">void</span> flushDelays();</div><div class="line"></div><div class="line">     <span class="comment">// --- set biquad coeffieicnets directly </span></div><div class="line">     <span class="keywordtype">void</span> setCoeffs(BQCoeffs&amp; _coeffs);</div><div class="line"></div><div class="line">     <span class="comment">// --- copy biquad coeffieicnets to a destination</span></div><div class="line">     <span class="keywordtype">void</span> copyCoeffs(BQAudioFilter&amp; destination;</div><div class="line"></div><div class="line">     <span class="comment">// --- run the filter</span></div><div class="line">     <span class="keywordtype">double</span> processAudioSample(<span class="keywordtype">double</span> xn);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">     <span class="keyword">enum</span> { a0, a1, a2, b1, b2, c0, d0 };</div><div class="line">     <span class="keyword">enum</span> { xz1, xz2, yz1, yz2, numStates };</div><div class="line">     <span class="keywordtype">double</span> state[4] = { 0.0, 0.0, 0.0, 0.0 }; <span class="comment">//&lt; state registers</span></div><div class="line">     BQCoeffs bq;                              <span class="comment">//&lt; coefficients</span></div><div class="line">};</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><h2>FilterModule Code </h2>
<p>We can design this module in the same manner as the ModuleCores by starting with the .h file, adding members, and then modifying the five operational phases in the .cpp file, starting with the constructor and working down through the rest of the functions thinking about those five phases and adding the code to implement them.</p>
<h2><a class="el" href="filtermodule_8h.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">filtermodule.h</a> file </h2>
<p>We'll need to add two of the BQAudioFilter object to the SynthModule along with a couple of helper members and enumerations. Add this to you class declaration:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">     std::shared_ptr&lt;FilterParameters&gt; parameters = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line">     <span class="keywordtype">double</span> sampleRate = 0.0; </div><div class="line">     <span class="keywordtype">double</span> midiPitch = 0.0; <span class="comment">// for keytrack</span></div><div class="line"></div><div class="line">     <span class="comment">// --- stereo filters and coefficients; see FX book</span></div><div class="line">     <span class="keyword">enum</span> { vicLPF2, vicBPF2 };</div><div class="line">     BQAudioFilter filters[STEREO_CHANNELS]; <span class="comment">// stereo pair of filters</span></div><div class="line">     </div><div class="line">     <span class="comment">// --- enum for coefficient calculations</span></div><div class="line">     <span class="keyword">enum</span> { a0, a1, a2, b1, b2, c0, d0 };</div><div class="line">}; </div><div class="line"><span class="comment">// end class declaration</span></div></div><!-- fragment --><h2><a class="el" href="filtermodule_8cpp.html" title="See also Designing Software Synthesizers in C++ 2nd Ed. by Will Pirkle. ">filtermodule.cpp</a> file </h2>
<p>We will go through the operational phase methods one at a time, just as with the other objects and following the same paradigm as the <a href="https://www.routledge.com/Designing-Software-Synthesizer-Plugins-in-C-With-Audio-DSP/Pirkle/p/book/9780367510466" target="_blank">synth book</a>. We can start with the constructor and add the support code to create the audio buffers and set the module strings and mod knob labels.</p>
<p><b>constructor</b> <br />
 Here's the code for the constructor; after creating the parameters and buffers, you see the code that is nearly identical to the ModuleCores for setting the module strings and mod knob labels. I am usign the enums to make the indexing a bit easier to read.</p>
<div class="fragment"><div class="line"><span class="comment">// --- construction</span></div><div class="line">FilterModule::FilterModule(std::shared_ptr&lt;MidiInputData&gt; _midiInputData,</div><div class="line">                           std::shared_ptr&lt;FilterParameters&gt; _parameters,</div><div class="line">                           uint32_t blockSize) :</div><div class="line">SynthModule(_midiInputData)</div><div class="line">, parameters(_parameters)</div><div class="line">{</div><div class="line">     <span class="comment">// --- standalone ONLY: parameters</span></div><div class="line">     <span class="keywordflow">if</span> (!parameters)</div><div class="line">     parameters.reset(<span class="keyword">new</span> FilterParameters);</div><div class="line"></div><div class="line">     <span class="comment">// --- create our audio buffers</span></div><div class="line">     audioBuffers.reset(<span class="keyword">new</span> SynthProcessInfo(<a class="code" href="group___constants-_enums.html#ga78fbb72adf903d34ebfb9ee3e48a07e5">STEREO_INPUTS</a>, <a class="code" href="group___constants-_enums.html#gabb96f9fa8f6757fd8c7797e0e05df0a3">STEREO_OUTPUTS</a>, blockSize));</div><div class="line"></div><div class="line">     <span class="comment">// --- module strings</span></div><div class="line">     moduleData.moduleStrings[vicLPF2] = <span class="stringliteral">&quot;VicLPF2&quot;</span>;       moduleData.moduleStrings[8] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[vicBPF2] = <span class="stringliteral">&quot;VicBPF2&quot;</span>;       moduleData.moduleStrings[9] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[2] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[10] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[3] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[11] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[4] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[12] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[5] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[13] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[6] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[14] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line">     moduleData.moduleStrings[7] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();  moduleData.moduleStrings[15] = <a class="code" href="group___constants-_enums.html#ga80e76224a09d421e5865520315cb4d84">empty_string</a>.c_str();</div><div class="line"></div><div class="line">     <span class="comment">// --- mod knobs</span></div><div class="line">     moduleData.modKnobStrings[MOD_KNOB_A] = <span class="stringliteral">&quot;Key Track&quot;</span>;</div><div class="line">     moduleData.modKnobStrings[MOD_KNOB_B] = <span class="stringliteral">&quot;B&quot;</span>;</div><div class="line">     moduleData.modKnobStrings[MOD_KNOB_C] = <span class="stringliteral">&quot;C&quot;</span>;</div><div class="line">     moduleData.modKnobStrings[MOD_KNOB_D] = <span class="stringliteral">&quot;D&quot;</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>reset()</b> <br />
 For the reset function, we only need to reset the filters which flushes the state registers. The BQAudioFilter is a simple object that is not a SynthModule and its reset() function does not require a sample rate. We do need to store the sample rate for the update() function later.</p>
<div class="fragment"><div class="line"><span class="comment">// --- reset/init</span></div><div class="line"><span class="keywordtype">bool</span> FilterModule::reset(<span class="keywordtype">double</span> _sampleRate)</div><div class="line">{</div><div class="line">     <span class="comment">// --- store</span></div><div class="line">     sampleRate = _sampleRate;</div><div class="line"></div><div class="line">     <span class="comment">// --- flush buffers in filters</span></div><div class="line">     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; STEREO_CHANNELS; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- reset; sample rate not needed</span></div><div class="line">          filters[i].reset();</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>update()</b> <br />
 The main purpose for the update() function is to recalculate the biquadratic coefficients based on the current filter parameters, fc and Q. We will add code later to modulate the filter cutoff frequency. The code here examines the selected filter index and recalculates the coefficients based on the curoff frequency, then sends that information to the filters. This code is inefficient because it does not check first to see if the parameters have been changed; you might consider adding that code as an exercise. The theory and coefficient calculations may be found in my FX book.</p>
<div class="fragment"><div class="line"><span class="comment">// --- update module state</span></div><div class="line"><span class="keywordtype">bool</span> FilterModule::update()</div><div class="line">{</div><div class="line">     <span class="comment">// --- to be modulated</span></div><div class="line">     <span class="keywordtype">double</span> filterFc = parameters-&gt;fc;</div><div class="line"></div><div class="line">     <span class="comment">// --- setup biquad structures and load with coefficients depending on filter type</span></div><div class="line">     <span class="keywordflow">if</span> (parameters-&gt;filterIndex == vicLPF2)</div><div class="line">     {</div><div class="line">          <span class="comment">// http://vicanek.de/articles/BiquadFits.pdf</span></div><div class="line">          <span class="keywordtype">double</span> theta_c = 2.0*<a class="code" href="group___constants-_enums.html#ga356efafabc82ea087ea04ab333668ffa">kPi</a>*filterFc / sampleRate;</div><div class="line">          <span class="keywordtype">double</span> q = 1.0 / (2.0*parameters-&gt;Q);</div><div class="line"></div><div class="line">          <span class="comment">// --- impulse invariant</span></div><div class="line">          <span class="keywordtype">double</span> b_1 = 0.0;</div><div class="line">          <span class="keywordtype">double</span> b_2 = exp(-2.0*q*theta_c);</div><div class="line">          <span class="keywordflow">if</span> (q &lt;= 1.0)</div><div class="line">          {</div><div class="line">               b_1 = -2.0*exp(-q*theta_c)*cos(pow((1.0 - q*q), 0.5)*theta_c);</div><div class="line">          }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">               b_1 = -2.0*exp(-q*theta_c)*cosh(pow((q*q - 1.0), 0.5)*theta_c);</div><div class="line">          }</div><div class="line"></div><div class="line">          <span class="comment">// --- LOOSE FIT --- //</span></div><div class="line">          <span class="keywordtype">double</span> f0 = theta_c / <a class="code" href="group___constants-_enums.html#ga356efafabc82ea087ea04ab333668ffa">kPi</a>; <span class="comment">// note f0 = fraction of pi, so that f0 = 1.0 = pi = Nyquist</span></div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> r0 = 1.0 + b_1 + b_2;</div><div class="line">          <span class="keywordtype">double</span> denom = (1.0 - f0*f0)*(1.0 - f0*f0) + (f0*f0) / (parameters-&gt;Q*parameters-&gt;Q);</div><div class="line">          denom = pow(denom, 0.5);</div><div class="line">          <span class="keywordtype">double</span> r1 = ((1.0 - b_1 + b_2)*f0*f0) / (denom);</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> a_0 = (r0 + r1) / 2.0;</div><div class="line">          <span class="keywordtype">double</span> a_1 = r0 - a_0;</div><div class="line">          <span class="keywordtype">double</span> a_2 = 0.0;</div><div class="line"></div><div class="line">          BQCoeffs bq;</div><div class="line">          bq.coeff[c0] = 1.0;</div><div class="line">          bq.coeff[d0] = 0.0;</div><div class="line">          bq.coeff[a0] = a_0;</div><div class="line">          bq.coeff[a1] = a_1;</div><div class="line">          bq.coeff[a2] = a_2;</div><div class="line">          bq.coeff[b1] = b_1;</div><div class="line">          bq.coeff[b2] = b_2;</div><div class="line"></div><div class="line">          <span class="comment">// --- update on filters</span></div><div class="line">          filters[LEFT_CHANNEL].setCoeffs(bq);</div><div class="line">          filters[RIGHT_CHANNEL].setCoeffs(bq);</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameters-&gt;filterIndex == vicBPF2)</div><div class="line">     {</div><div class="line">          <span class="comment">// http://vicanek.de/articles/BiquadFits.pdf</span></div><div class="line">          <span class="keywordtype">double</span> theta_c = 2.0*<a class="code" href="group___constants-_enums.html#ga356efafabc82ea087ea04ab333668ffa">kPi</a>*filterFc / sampleRate;</div><div class="line">          <span class="keywordtype">double</span> q = 1.0 / (2.0*parameters-&gt;Q);</div><div class="line"></div><div class="line">          <span class="comment">// --- impulse invariant</span></div><div class="line">          <span class="keywordtype">double</span> b_1 = 0.0;</div><div class="line">          <span class="keywordtype">double</span> b_2 = exp(-2.0*q*theta_c);</div><div class="line">          <span class="keywordflow">if</span> (q &lt;= 1.0)</div><div class="line">          {</div><div class="line">               b_1 = -2.0*exp(-q*theta_c)*cos(pow((1.0 - q*q), 0.5)*theta_c);</div><div class="line">          }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">               b_1 = -2.0*exp(-q*theta_c)*cosh(pow((q*q - 1.0), 0.5)*theta_c);</div><div class="line">          }</div><div class="line"></div><div class="line">          <span class="comment">// --- LOOSE FIT --- //</span></div><div class="line">          <span class="keywordtype">double</span> f0 = theta_c / <a class="code" href="group___constants-_enums.html#ga356efafabc82ea087ea04ab333668ffa">kPi</a>; <span class="comment">// note f0 = fraction of pi, so that f0 = 1.0 = pi = Nyquist</span></div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> r0 = (1.0 + b_1 + b_2) / (<a class="code" href="group___constants-_enums.html#ga356efafabc82ea087ea04ab333668ffa">kPi</a>*f0*parameters-&gt;Q);</div><div class="line">          <span class="keywordtype">double</span> denom = (1.0 - f0*f0)*(1.0 - f0*f0) + (f0*f0) / (parameters-&gt;Q*parameters-&gt;Q);</div><div class="line">          denom = pow(denom, 0.5);</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> r1 = ((1.0 - b_1 + b_2)*(f0 / parameters-&gt;Q)) / (denom);</div><div class="line">          </div><div class="line">          <span class="keywordtype">double</span> a_1 = -r1 / 2.0;</div><div class="line">          <span class="keywordtype">double</span> a_0 = (r0 - a_1) / 2.0;</div><div class="line">          <span class="keywordtype">double</span> a_2 = -a_0 - a_1;</div><div class="line"></div><div class="line">          BQCoeffs bq;</div><div class="line">          bq.coeff[c0] = 1.0;</div><div class="line">          bq.coeff[d0] = 0.0;</div><div class="line">          bq.coeff[a0] = a_0;</div><div class="line">          bq.coeff[a1] = a_1;</div><div class="line">          bq.coeff[a2] = a_2;</div><div class="line">          bq.coeff[b1] = b_1;</div><div class="line">          bq.coeff[b2] = b_2;</div><div class="line"></div><div class="line">          <span class="comment">// --- update on filters</span></div><div class="line">          filters[LEFT_CHANNEL].setCoeffs(bq);</div><div class="line">          filters[RIGHT_CHANNEL].setCoeffs(bq);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// handled</span></div><div class="line">}</div><div class="line"><span class="comment">// --- </span></div></div><!-- fragment --><p><b>render()</b> <br />
 To render the filters, we need to pick up the audio input samples from the input buffers, process them through the filters, and write the outputs into the output buffer over the requested block of audio data. We've already seen much of this code in the previous sections and here you can see how to access the audio input buffers. And, notice how the update() function is called directly from render() to force the sequence of operations of update -&gt; render.</p>
<div class="fragment"><div class="line"><span class="comment">// --- render filters</span></div><div class="line"><span class="keywordtype">bool</span> FilterModule::render(uint32_t samplesToProcess)</div><div class="line">{</div><div class="line">     <span class="comment">// --- update parameters for this block</span></div><div class="line">     update();</div><div class="line"></div><div class="line">     <span class="comment">// --- FilterModule processes every sample into output buffers</span></div><div class="line">     <span class="keywordtype">float</span>* leftInBuffer = audioBuffers-&gt;getInputBuffer(LEFT_CHANNEL);</div><div class="line">     <span class="keywordtype">float</span>* rightInBuffer = audioBuffers-&gt;getInputBuffer(RIGHT_CHANNEL);</div><div class="line">     <span class="keywordtype">float</span>* leftOutBuffer = audioBuffers-&gt;getOutputBuffer(LEFT_CHANNEL);</div><div class="line">     <span class="keywordtype">float</span>* rightOutBuffer = audioBuffers-&gt;getOutputBuffer(RIGHT_CHANNEL);</div><div class="line"></div><div class="line">     <span class="comment">// --- process block</span></div><div class="line">     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; samplesToProcess; i++)</div><div class="line">     {</div><div class="line">          <span class="comment">// --- stereo output</span></div><div class="line">          leftOutBuffer[i] = filters[LEFT_CHANNEL].processAudioSample(leftInBuffer[i]);</div><div class="line">          rightOutBuffer[i] = filters[RIGHT_CHANNEL].processAudioSample(rightInBuffer[i]);</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// --- </span></div></div><!-- fragment --><p><b>doNoteOn() and doNoteOff()</b> <br />
 We only need to alter the doNoteOn() method to pick up the MIDI pitch of the note played. This will be used for key track modulation in the next section. There is nothing to do for the note-off handler.</p>
<div class="fragment"><div class="line"><span class="comment">// --- note on</span></div><div class="line"><span class="keywordtype">bool</span> FilterModule::doNoteOn(MIDINoteEvent&amp; noteEvent)</div><div class="line">{</div><div class="line">     <span class="comment">// --- just save for keytrack</span></div><div class="line">     midiPitch = noteEvent.midiPitch;</div><div class="line"></div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// --- nothing to do in note-off</span></div><div class="line"><span class="keywordtype">bool</span> FilterModule::doNoteOff(MIDINoteEvent&amp; noteEvent)</div><div class="line">{</div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><h2>Testing FilterModule </h2>
<p>Testing this object will be the same as the previous objects and you may use your MinSynth voice object, or test it independently following the same familiar programmign pattern.</p>
<p><b>Create the Filter Instance</b> <br />
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="filtermodule_8h.html">filtermodule.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// --- the filter declaration</span></div><div class="line">std::unique_ptr&lt;SynthLab::FilterModule&gt; filterModule = <span class="keyword">nullptr</span>;</div><div class="line"></div><div class="line"><span class="comment">// --- instantiation</span></div><div class="line">uint32_t blockSize = 64; <span class="comment">//&lt; make this 1 for processing single samples if that is easier for you</span></div><div class="line"></div><div class="line"><span class="comment">// --- create the smart pointer (this &quot;reset&quot; function has no relationship to the SynthModule::reset() method)</span></div><div class="line">filterModule.reset(<span class="keyword">new</span> <a class="code" href="class_synth_lab_1_1_filter_module.html">SynthLab::FilterModule</a>(<span class="keyword">nullptr</span>, <span class="comment">/* MIDI input data */</span></div><div class="line">             <span class="keyword">nullptr</span>,                                  <span class="comment">/* parameters */</span></div><div class="line">             blockSize));                              <span class="comment">/* process blocks (block size = 1 for processing samples instead)*/</span></div><div class="line"></div><div class="line"><span class="comment">// --- reset the object with the SynthModule method:</span></div><div class="line">filterModule-&gt;reset(44100.0); <span class="comment">//&lt; get fs from your framework</span></div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Update the object to test Filter [0]</b> <br />
 Here we will set the filterIndex to 0 for the "Vic LPF2" filter and then set the fc = 500.0 Hz and Q = 10.0 producing a very resonant filter whose affect on the oscillator will be easy to hear.</p>
<div class="fragment"><div class="line"><span class="comment">// --- get parameters</span></div><div class="line">std::shared_ptr&lt;SynthLab::FilterParameters&gt; filterModuleParameters = filterModule-&gt;getParameters();</div><div class="line"><span class="keywordflow">if</span> (filterModuleParameters) <span class="comment">// should never fail</span></div><div class="line">{</div><div class="line">     <span class="comment">// --- set the variable</span></div><div class="line">     filterModuleParameters-&gt;filterIndex = 0; <span class="comment">// LPF2</span></div><div class="line">     filterModuleParameters-&gt;fc = 500.0;</div><div class="line">     filterModuleParameters-&gt;Q = 10.0;</div><div class="line"></div><div class="line">     <span class="comment">// --- recalc coefficients</span></div><div class="line">     filterModule-&gt;update();</div><div class="line">}</div><div class="line"><span class="comment">// ---</span></div></div><!-- fragment --><p><b>Send a Note-On Event</b> <br />
 You can get this from a live MIDI source or fake it to test as done here. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- prepare a MIDI event for note-on</span></div><div class="line"><a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html">SynthLab::MIDINoteEvent</a> midiEvent;</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a> = 60;</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a7c1a0e203aa66105e2f69d3f2850881d">midiPitch</a> = <a class="code" href="group___m_i_d_i_functions.html#gad3b90b92d9aa8104d1b4fa897b5db750">SynthLab::midiNoteNumberToOscFrequency</a>(midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#ab39c1eb0f451972d37592e99636f8e06">midiNoteNumber</a>);</div><div class="line">midiEvent.<a class="code" href="struct_synth_lab_1_1_m_i_d_i_note_event.html#a93dce735febfe26bc91a4b17922adec9">midiNoteVelocity</a> = 127;</div><div class="line"></div><div class="line"><span class="comment">// --- send the message</span></div><div class="line">filterModule-&gt;doNoteOn(midiEvent);</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Render the Filter</b> <br />
 Render the filters and loop over the audio block to process input to output. Remember that we set the blockSize variable at construction time. This code shows both the oscillator render and the transfer of data from oscillator to filter, prior to the filter render. <br />
</p>
<div class="fragment"><div class="line"><span class="comment">// --- render output</span></div><div class="line">addOsc-&gt;render();</div><div class="line"></div><div class="line"><span class="comment">// --- use helper function</span></div><div class="line"><a class="code" href="group___synth_functions.html#ga7edcac97d707b99911e4cd6dd4a87efb">SynthLab::copyOutputToInput</a>(addOsc-&gt;getAudioBuffers(),        <span class="comment">/* output buffer */</span></div><div class="line">                            filterModule-&gt;getAudioBuffers(),  <span class="comment">/* copied to input buffer */</span></div><div class="line">                            SynthLab::STEREO_TO_STEREO,       <span class="comment">/* stereo to stereo */</span></div><div class="line">                            blockSize);                       <span class="comment">/* blocksize */</span></div><div class="line">                            </div><div class="line"><span class="comment">// --- render filter processing</span></div><div class="line">filterModule-&gt;render();</div><div class="line"></div><div class="line"><span class="comment">// --- get output buffer pointers</span></div><div class="line"><span class="keywordtype">float</span>* leftOutBuffer = filterModule-&gt;getAudioBuffers()-&gt;getOutputBuffer(SynthLab::LEFT_CHANNEL);</div><div class="line"><span class="keywordtype">float</span>* rightOutBuffer = filterModule-&gt;getAudioBuffers()-&gt;getOutputBuffer(SynthLab::RIGHT_CHANNEL);</div><div class="line"></div><div class="line"><span class="comment">// --- loop over filter output block</span></div><div class="line"><span class="keywordflow">for</span> (uint32_t i = 0; i &lt; blockSize; i++)</div><div class="line">{</div><div class="line">     <span class="keywordtype">float</span> leftSample = leftOutBuffer[i];</div><div class="line">     <span class="keywordtype">float</span> rightSample = rightOutBuffer[i];</div><div class="line">     </div><div class="line">     <span class="comment">// --- send samples to your output buffer</span></div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p>Test the filter and check to make sure it is functioning correctly. Next, change the filter type to the Vic BPF2 variety and play with the fc and Q values a bit.</p>
<p><b>Update the object for Filter [1]</b> <br />
 </p><div class="fragment"><div class="line"><span class="comment">// --- get parameters</span></div><div class="line">std::shared_ptr&lt;SynthLab::FilterParameters&gt; filterModuleParameters = filterModule-&gt;getParameters();</div><div class="line"><span class="keywordflow">if</span> (filterModuleParameters) <span class="comment">// should never fail</span></div><div class="line">{</div><div class="line">     <span class="comment">// --- set the variable</span></div><div class="line">     filterModuleParameters-&gt;filterIndex = 1; <span class="comment">// LPF2</span></div><div class="line"></div><div class="line">     <span class="comment">// --- adjust harmonic filter params</span></div><div class="line">     filterModuleParameters-&gt;fc = 500.0;</div><div class="line">     filterModuleParameters-&gt;Q = 20.0;</div><div class="line"></div><div class="line">     <span class="comment">// --- update phase</span></div><div class="line">     filterModule-&gt;update();</div><div class="line">}</div><div class="line"><span class="comment">//</span></div></div><!-- fragment --><p><b>Testing Filter [1]</b> <br />
 Test the filter to verify operation. Once satisified, move to the next section and add the cutoff modulation code.</p>
<ul>
<li><a class="el" href="filter_mod.html">Filter Cutoff Modulation</a></li>
</ul>
<p><br />
 </p><div class="image">
<img src="synthlab_4.png" alt="synthlab_4.png"/>
</div>
<p> <br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">SynthLab Developer&#39;s Guide</a></li><li class="navelem"><a class="el" href="synth_modules.html">SynthModule Progamming</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
